"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./lib/api-services.ts":
/*!*****************************!*\
  !*** ./lib/api-services.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addServicoFavorito: function() { return /* binding */ addServicoFavorito; },\n/* harmony export */   createCategoriaServico: function() { return /* binding */ createCategoriaServico; },\n/* harmony export */   createCidadao: function() { return /* binding */ createCidadao; },\n/* harmony export */   createPedido: function() { return /* binding */ createPedido; },\n/* harmony export */   createTipoServico: function() { return /* binding */ createTipoServico; },\n/* harmony export */   deleteCategoriaServico: function() { return /* binding */ deleteCategoriaServico; },\n/* harmony export */   getCategoriaServicoById: function() { return /* binding */ getCategoriaServicoById; },\n/* harmony export */   getCidadaoByDocumento: function() { return /* binding */ getCidadaoByDocumento; },\n/* harmony export */   getCidadaoById: function() { return /* binding */ getCidadaoById; },\n/* harmony export */   getCurrentUser: function() { return /* binding */ getCurrentUser; },\n/* harmony export */   getPedidoByCodigo: function() { return /* binding */ getPedidoByCodigo; },\n/* harmony export */   getPedidoById: function() { return /* binding */ getPedidoById; },\n/* harmony export */   listCategoriasServicos: function() { return /* binding */ listCategoriasServicos; },\n/* harmony export */   listCidadaos: function() { return /* binding */ listCidadaos; },\n/* harmony export */   listDashboardItems: function() { return /* binding */ listDashboardItems; },\n/* harmony export */   listPedidos: function() { return /* binding */ listPedidos; },\n/* harmony export */   listPedidosByCidadao: function() { return /* binding */ listPedidosByCidadao; },\n/* harmony export */   listPedidosDoUsuarioLogado: function() { return /* binding */ listPedidosDoUsuarioLogado; },\n/* harmony export */   listServicosFavoritos: function() { return /* binding */ listServicosFavoritos; },\n/* harmony export */   listTiposServicos: function() { return /* binding */ listTiposServicos; },\n/* harmony export */   listTiposServicosByCategoria: function() { return /* binding */ listTiposServicosByCategoria; },\n/* harmony export */   login: function() { return /* binding */ login; },\n/* harmony export */   logout: function() { return /* binding */ logout; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   removeServicoFavorito: function() { return /* binding */ removeServicoFavorito; },\n/* harmony export */   toggleFavorito: function() { return /* binding */ toggleFavorito; },\n/* harmony export */   updateCategoriaServico: function() { return /* binding */ updateCategoriaServico; },\n/* harmony export */   updateCidadao: function() { return /* binding */ updateCidadao; },\n/* harmony export */   updatePedidoStatus: function() { return /* binding */ updatePedidoStatus; },\n/* harmony export */   updateUserProfile: function() { return /* binding */ updateUserProfile; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _api_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api-config */ \"(app-pages-browser)/./lib/api-config.ts\");\n/**\n * Serviços de API para o sistema Simple\n * Este arquivo contém as funções para interagir com o backend\n */ // First install axios: npm install axios @types/axios\n\n\n// Cliente axios configurado\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n    baseURL: _api_config__WEBPACK_IMPORTED_MODULE_0__.API_BASE,\n    timeout: _api_config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT,\n    headers: _api_config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS\n});\n// Interceptor para adicionar token de autenticação\napiClient.interceptors.request.use((config)=>{\n    if (true) {\n        // Não adicionar token de autenticação para a rota de login ou registro\n        if (config.url === \"/auth/login\" || config.url === \"/auth/register\") {\n            return config;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (token) {\n            if (!config.headers) config.headers = new axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].AxiosHeaders();\n            config.headers.Authorization = \"Bearer \".concat(token);\n        }\n    }\n    return config;\n});\n// Interceptor para tratar respostas globais, incluindo erros de autenticação\napiClient.interceptors.response.use((response)=>response, (error)=>{\n    const currentPath =  true ? window.location.pathname : 0;\n    // Verifica se o erro é 401 (Não Autorizado) OU 403 (Proibido)\n    if (error.response && (error.response.status === 401 || error.response.status === 403)) {\n        // Evita loops de redirecionamento se já estiver na página de login ou registro\n        if (currentPath && currentPath !== \"/login\" && currentPath !== \"/register\") {\n            logout(); // Limpa o token e cookies\n            // Redireciona para a página de login\n            if (true) {\n                window.location.href = \"/login\";\n            }\n            // Retorna uma promessa que nunca resolve para evitar que o chamador original\n            // tente atualizar o estado de um componente desmontado.\n            return new Promise(()=>{});\n        }\n    }\n    // Para todos os outros erros, ou se já estiver em /login ou /register, rejeita a promessa\n    // para que o tratamento de erro local possa ocorrer.\n    return Promise.reject(error);\n});\n/**\n * Trata erros da API de forma padronizada\n */ const handleApiError = (error)=>{\n    if (error.response) {\n        // O servidor respondeu com um status de erro\n        const data = error.response.data;\n        return {\n            message: data.message || data.error || \"Erro desconhecido\",\n            status: error.response.status,\n            timestamp: data.timestamp\n        };\n    } else if (error.request) {\n        // A requisição foi feita mas não houve resposta\n        return {\n            message: \"N\\xe3o foi poss\\xedvel conectar ao servidor\",\n            status: 0\n        };\n    } else {\n        // Erro ao configurar a requisição\n        return {\n            message: error.message || \"Erro ao processar a requisi\\xe7\\xe3o\",\n            status: 0\n        };\n    }\n};\n/**\n * Realiza login no sistema\n */ const login = async (credentials)=>{\n    try {\n        const response = await apiClient.post(\"/auth/login\", credentials);\n        // Armazena o token para uso futuro\n        if (true) {\n            localStorage.setItem(\"token\", response.data.token);\n            // Salva o token como cookie\n            document.cookie = \"token=\".concat(response.data.token, \"; path=/; max-age=\").concat(60 * 60 * 24 * 7, \"; SameSite=Lax\"); // Expira em 7 dias\n        }\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Realiza logout do sistema\n */ const logout = ()=>{\n    if (true) {\n        localStorage.removeItem(\"token\");\n        // Remove o cookie do token\n        document.cookie = \"token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Lax\";\n    }\n};\n/**\n * Registra um novo usuário\n */ const registerUser = async (user)=>{\n    try {\n        const response = await apiClient.post(\"/auth/register\", user);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém o usuário atual\n */ const getCurrentUser = async ()=>{\n    try {\n        const response = await apiClient.get(\"/users/me\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza o perfil do usuário atual\n */ const updateUserProfile = async (userData)=>{\n    try {\n        const response = await apiClient.put(\"/users/me\", userData);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista todos os cidadãos (paginado)\n */ const listCidadaos = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/cidadaos?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um cidadão pelo ID\n */ const getCidadaoById = async (id)=>{\n    try {\n        const response = await apiClient.get(\"/cidadaos/\".concat(id));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um cidadão pelo documento\n */ const getCidadaoByDocumento = async (tipoDocumento, numeroDocumento)=>{\n    try {\n        const response = await apiClient.get(\"/cidadaos/documento?tipoDocumento=\".concat(tipoDocumento, \"&numeroDocumento=\").concat(numeroDocumento));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Cria um novo cidadão\n */ const createCidadao = async (cidadao)=>{\n    try {\n        const response = await apiClient.post(\"/cidadaos\", cidadao);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza um cidadão existente\n */ const updateCidadao = async (id, cidadao)=>{\n    try {\n        const response = await apiClient.put(\"/cidadaos/\".concat(id), cidadao);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista todos os pedidos (paginado)\n */ const listPedidos = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/pedidos?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um pedido pelo ID\n */ const getPedidoById = async (id)=>{\n    try {\n        const response = await apiClient.get(\"/pedidos/\".concat(id));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um pedido pelo código de acompanhamento\n */ const getPedidoByCodigo = async (codigo)=>{\n    try {\n        const response = await apiClient.get(\"/pedidos/codigo/\".concat(codigo));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista pedidos por cidadão (paginado)\n */ const listPedidosByCidadao = async function(cidadaoId) {\n    let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, size = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    try {\n        const response = await apiClient.get(\"/pedidos/cidadao/\".concat(cidadaoId, \"?page=\").concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Cria um novo pedido\n */ const createPedido = async (pedido)=>{\n    try {\n        const response = await apiClient.post(\"/pedidos\", pedido);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza o status de um pedido\n */ const updatePedidoStatus = async (id, statusId)=>{\n    try {\n        const response = await apiClient.patch(\"/pedidos/\".concat(id, \"/status/\").concat(statusId));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os tipos de serviços disponíveis\n */ const listTiposServicos = async ()=>{\n    try {\n        const response = await apiClient.get(\"/tipos-servicos\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Cria um novo tipo de serviço\n */ const createTipoServico = async (serviceData)=>{\n    try {\n        const response = await apiClient.post(\"/tipos-servicos\", serviceData);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n// Funções CRUD para CategoriaServico\n/**\n * Lista todas as categorias de serviços\n */ const listCategoriasServicos = async ()=>{\n    try {\n        const response = await apiClient.get(\"/categorias-servicos\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Cria uma nova categoria de serviço\n */ const createCategoriaServico = async (categoriaData)=>{\n    try {\n        const response = await apiClient.post(\"/categorias-servicos\", categoriaData);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém uma categoria de serviço pelo ID\n */ const getCategoriaServicoById = async (id)=>{\n    try {\n        const response = await apiClient.get(\"/categorias-servicos/\".concat(id));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza uma categoria de serviço existente\n */ const updateCategoriaServico = async (id, categoriaData)=>{\n    try {\n        const response = await apiClient.put(\"/categorias-servicos/\".concat(id), categoriaData);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Deleta uma categoria de serviço\n */ const deleteCategoriaServico = async (id)=>{\n    try {\n        await apiClient.delete(\"/categorias-servicos/\".concat(id));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os tipos de serviços por categoria ID\n */ const listTiposServicosByCategoria = async (categoriaId)=>{\n    try {\n        const response = await apiClient.get(\"/tipos-servicos/categoria/\".concat(categoriaId));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os serviços favoritos do usuário\n */ const listServicosFavoritos = async ()=>{\n    try {\n        const response = await apiClient.get(\"/favoritos\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Adiciona um serviço aos favoritos\n */ const addServicoFavorito = async (servicoId)=>{\n    try {\n        await apiClient.post(\"/favoritos/\".concat(servicoId));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Remove um serviço dos favoritos\n */ const removeServicoFavorito = async (servicoId)=>{\n    try {\n        await apiClient.delete(\"/favoritos/\".concat(servicoId));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Adiciona ou remove um serviço dos favoritos do usuário atual\n */ const toggleFavorito = async (tipoServicoId)=>{\n    try {\n        // O endpoint exato pode variar, ajuste conforme a API do backend\n        // Pode ser um POST para adicionar e um DELETE para remover, ou um único endpoint que faz o toggle.\n        // Aqui, vamos assumir um endpoint POST que faz o toggle.\n        // Se o backend retornar os favoritos atualizados, você pode ajustar o tipo de retorno.\n        await apiClient.post(\"/usuarios/me/favoritos/\".concat(tipoServicoId));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os itens do dashboard (paginado)\n */ const listPedidosDoUsuarioLogado = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/pedidos/meus-pedidos?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\nconst listDashboardItems = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/dashboard?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGktc2VydmljZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFRCxzREFBc0Q7QUFDNUI7QUFFZ0Q7QUFrQjFFLDRCQUE0QjtBQUM1QixNQUFNSSxZQUFZSiw2Q0FBS0EsQ0FBQ0ssTUFBTSxDQUFDO0lBQzdCQyxTQUFTTCxpREFBUUE7SUFDakJNLFNBQVNKLHdEQUFlQTtJQUN4QkssU0FBU04sd0RBQWVBO0FBQzFCO0FBRUEsbURBQW1EO0FBQ25ERSxVQUFVSyxZQUFZLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLENBQUNDO0lBQ2xDLElBQUksSUFBa0IsRUFBYTtRQUNqQyx1RUFBdUU7UUFDdkUsSUFBSUEsT0FBT0MsR0FBRyxLQUFLLGlCQUFpQkQsT0FBT0MsR0FBRyxLQUFLLGtCQUFrQjtZQUNuRSxPQUFPRDtRQUNUO1FBRUEsTUFBTUUsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLElBQUlGLE9BQU87WUFDVCxJQUFJLENBQUNGLE9BQU9KLE9BQU8sRUFBRUksT0FBT0osT0FBTyxHQUFHLElBQUlSLDZDQUFLQSxDQUFDaUIsWUFBWTtZQUM1REwsT0FBT0osT0FBTyxDQUFDVSxhQUFhLEdBQUcsVUFBZ0IsT0FBTko7UUFDM0M7SUFDRjtJQUNBLE9BQU9GO0FBQ1Q7QUFFQSw2RUFBNkU7QUFDN0VSLFVBQVVLLFlBQVksQ0FBQ1UsUUFBUSxDQUFDUixHQUFHLENBQ2pDLENBQUNRLFdBQWFBLFVBQ2QsQ0FBQ0M7SUFDQyxNQUFNQyxjQUFjLEtBQWtCLEdBQWNDLE9BQU9DLFFBQVEsQ0FBQ0MsUUFBUSxHQUFHO0lBQy9FLDhEQUE4RDtJQUM5RCxJQUFJSixNQUFNRCxRQUFRLElBQUtDLENBQUFBLE1BQU1ELFFBQVEsQ0FBQ00sTUFBTSxLQUFLLE9BQU9MLE1BQU1ELFFBQVEsQ0FBQ00sTUFBTSxLQUFLLEdBQUUsR0FBSTtRQUN0RiwrRUFBK0U7UUFDL0UsSUFBSUosZUFBZUEsZ0JBQWdCLFlBQVlBLGdCQUFnQixhQUFhO1lBQzFFSyxVQUFVLDBCQUEwQjtZQUNwQyxxQ0FBcUM7WUFDckMsSUFBSSxJQUFrQixFQUFhO2dCQUNqQ0osT0FBT0MsUUFBUSxDQUFDSSxJQUFJLEdBQUc7WUFDekI7WUFDQSw2RUFBNkU7WUFDN0Usd0RBQXdEO1lBQ3hELE9BQU8sSUFBSUMsUUFBUSxLQUFPO1FBQzVCO0lBQ0Y7SUFDQSwwRkFBMEY7SUFDMUYscURBQXFEO0lBQ3JELE9BQU9BLFFBQVFDLE1BQU0sQ0FBQ1Q7QUFDeEI7QUFHRjs7Q0FFQyxHQUNELE1BQU1VLGlCQUFpQixDQUFDVjtJQUN0QixJQUFJQSxNQUFNRCxRQUFRLEVBQUU7UUFDbEIsNkNBQTZDO1FBQzdDLE1BQU1ZLE9BQU9YLE1BQU1ELFFBQVEsQ0FBQ1ksSUFBSTtRQUNoQyxPQUFPO1lBQ0xDLFNBQVNELEtBQUtDLE9BQU8sSUFBSUQsS0FBS1gsS0FBSyxJQUFJO1lBQ3ZDSyxRQUFRTCxNQUFNRCxRQUFRLENBQUNNLE1BQU07WUFDN0JRLFdBQVdGLEtBQUtFLFNBQVM7UUFDM0I7SUFDRixPQUFPLElBQUliLE1BQU1WLE9BQU8sRUFBRTtRQUN4QixnREFBZ0Q7UUFDaEQsT0FBTztZQUNMc0IsU0FBUztZQUNUUCxRQUFRO1FBQ1Y7SUFDRixPQUFPO1FBQ0wsa0NBQWtDO1FBQ2xDLE9BQU87WUFDTE8sU0FBU1osTUFBTVksT0FBTyxJQUFJO1lBQzFCUCxRQUFRO1FBQ1Y7SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxNQUFNUyxRQUFRLE9BQU9DO0lBQzFCLElBQUk7UUFDRixNQUFNaEIsV0FBVyxNQUFNZixVQUFVZ0MsSUFBSSxDQUFlLGVBQWVEO1FBQ25FLG1DQUFtQztRQUNuQyxJQUFJLElBQWtCLEVBQWE7WUFDakNwQixhQUFhc0IsT0FBTyxDQUFDLFNBQVNsQixTQUFTWSxJQUFJLENBQUNqQixLQUFLO1lBQ2pELDRCQUE0QjtZQUM1QndCLFNBQVNDLE1BQU0sR0FBRyxTQUFpRCxPQUF4Q3BCLFNBQVNZLElBQUksQ0FBQ2pCLEtBQUssRUFBQyxzQkFBcUMsT0FBakIsS0FBSyxLQUFLLEtBQUssR0FBRSxtQkFBaUIsbUJBQW1CO1FBQzFIO1FBQ0EsT0FBT0ssU0FBU1ksSUFBSTtJQUN0QixFQUFFLE9BQU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1NLFNBQVM7SUFDcEIsSUFBSSxJQUFrQixFQUFhO1FBQ2pDWCxhQUFheUIsVUFBVSxDQUFDO1FBQ3hCLDJCQUEyQjtRQUMzQkYsU0FBU0MsTUFBTSxHQUFHO0lBQ3BCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTUUsZUFBZSxPQUFPQztJQUNqQyxJQUFJO1FBQ0YsTUFBTXZCLFdBQVcsTUFBTWYsVUFBVWdDLElBQUksQ0FBa0Isa0JBQWtCTTtRQUN6RSxPQUFPdkIsU0FBU1ksSUFBSTtJQUN0QixFQUFFLE9BQU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU11QixpQkFBaUI7SUFDNUIsSUFBSTtRQUNGLE1BQU14QixXQUFXLE1BQU1mLFVBQVV3QyxHQUFHLENBQWtCO1FBQ3RELE9BQU96QixTQUFTWSxJQUFJO0lBQ3RCLEVBQUUsT0FBT1gsT0FBTztRQUNkLE1BQU1VLGVBQWVWO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTXlCLG9CQUFvQixPQUFPQztJQUN0QyxJQUFJO1FBQ0YsTUFBTTNCLFdBQVcsTUFBTWYsVUFBVTJDLEdBQUcsQ0FBa0IsYUFBYUQ7UUFDbkUsT0FBTzNCLFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNNEIsZUFBZTtRQUMxQkMsd0VBQWUsR0FDZkMsd0VBQWU7SUFFZixJQUFJO1FBQ0YsTUFBTS9CLFdBQVcsTUFBTWYsVUFBVXdDLEdBQUcsQ0FDbEMsa0JBQStCTSxPQUFiRCxNQUFLLFVBQWEsT0FBTEM7UUFFakMsT0FBTy9CLFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNK0IsaUJBQWlCLE9BQU9DO0lBQ25DLElBQUk7UUFDRixNQUFNakMsV0FBVyxNQUFNZixVQUFVd0MsR0FBRyxDQUFrQixhQUFnQixPQUFIUTtRQUNuRSxPQUFPakMsU0FBU1ksSUFBSTtJQUN0QixFQUFFLE9BQU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1pQyx3QkFBd0IsT0FDbkNDLGVBQ0FDO0lBRUEsSUFBSTtRQUNGLE1BQU1wQyxXQUFXLE1BQU1mLFVBQVV3QyxHQUFHLENBQ2xDLHFDQUFzRVcsT0FBakNELGVBQWMscUJBQW1DLE9BQWhCQztRQUV4RSxPQUFPcEMsU0FBU1ksSUFBSTtJQUN0QixFQUFFLE9BQU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1vQyxnQkFBZ0IsT0FBT0M7SUFDbEMsSUFBSTtRQUNGLE1BQU10QyxXQUFXLE1BQU1mLFVBQVVnQyxJQUFJLENBQWtCLGFBQWFxQjtRQUNwRSxPQUFPdEMsU0FBU1ksSUFBSTtJQUN0QixFQUFFLE9BQU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1zQyxnQkFBZ0IsT0FDM0JOLElBQ0FLO0lBRUEsSUFBSTtRQUNGLE1BQU10QyxXQUFXLE1BQU1mLFVBQVUyQyxHQUFHLENBQWtCLGFBQWdCLE9BQUhLLEtBQU1LO1FBQ3pFLE9BQU90QyxTQUFTWSxJQUFJO0lBQ3RCLEVBQUUsT0FBT1gsT0FBTztRQUNkLE1BQU1VLGVBQWVWO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTXVDLGNBQWM7UUFDekJWLHdFQUFlLEdBQ2ZDLHdFQUFlO0lBRWYsSUFBSTtRQUNGLE1BQU0vQixXQUFXLE1BQU1mLFVBQVV3QyxHQUFHLENBQ2xDLGlCQUE4Qk0sT0FBYkQsTUFBSyxVQUFhLE9BQUxDO1FBRWhDLE9BQU8vQixTQUFTWSxJQUFJO0lBQ3RCLEVBQUUsT0FBT1gsT0FBTztRQUNkLE1BQU1VLGVBQWVWO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTXdDLGdCQUFnQixPQUFPUjtJQUNsQyxJQUFJO1FBQ0YsTUFBTWpDLFdBQVcsTUFBTWYsVUFBVXdDLEdBQUcsQ0FBaUIsWUFBZSxPQUFIUTtRQUNqRSxPQUFPakMsU0FBU1ksSUFBSTtJQUN0QixFQUFFLE9BQU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU15QyxvQkFBb0IsT0FBT0M7SUFDdEMsSUFBSTtRQUNGLE1BQU0zQyxXQUFXLE1BQU1mLFVBQVV3QyxHQUFHLENBQWlCLG1CQUEwQixPQUFQa0I7UUFDeEUsT0FBTzNDLFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNMkMsdUJBQXVCLGVBQ2xDQztRQUNBZix3RUFBZSxHQUNmQyx3RUFBZTtJQUVmLElBQUk7UUFDRixNQUFNL0IsV0FBVyxNQUFNZixVQUFVd0MsR0FBRyxDQUNsQyxvQkFBc0NLLE9BQWxCZSxXQUFVLFVBQXFCZCxPQUFiRCxNQUFLLFVBQWEsT0FBTEM7UUFFckQsT0FBTy9CLFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNNkMsZUFBZSxPQUFPQztJQUNqQyxJQUFJO1FBQ0YsTUFBTS9DLFdBQVcsTUFBTWYsVUFBVWdDLElBQUksQ0FBaUIsWUFBWThCO1FBQ2xFLE9BQU8vQyxTQUFTWSxJQUFJO0lBQ3RCLEVBQUUsT0FBT1gsT0FBTztRQUNkLE1BQU1VLGVBQWVWO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTStDLHFCQUFxQixPQUNoQ2YsSUFDQWdCO0lBRUEsSUFBSTtRQUNGLE1BQU1qRCxXQUFXLE1BQU1mLFVBQVVpRSxLQUFLLENBQWlCLFlBQXlCRCxPQUFiaEIsSUFBRyxZQUFtQixPQUFUZ0I7UUFDaEYsT0FBT2pELFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNa0Qsb0JBQW9CO0lBQy9CLElBQUk7UUFDRixNQUFNbkQsV0FBVyxNQUFNZixVQUFVd0MsR0FBRyxDQUFnQjtRQUNwRCxPQUFPekIsU0FBU1ksSUFBSTtJQUN0QixFQUFFLE9BQU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1tRCxvQkFBb0IsT0FBT0M7SUFDdEMsSUFBSTtRQUNGLE1BQU1yRCxXQUFXLE1BQU1mLFVBQVVnQyxJQUFJLENBQWMsbUJBQW1Cb0M7UUFDdEUsT0FBT3JELFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUYscUNBQXFDO0FBQ3JDOztDQUVDLEdBQ00sTUFBTXFELHlCQUF5QjtJQUNwQyxJQUFJO1FBQ0YsTUFBTXRELFdBQVcsTUFBTWYsVUFBVXdDLEdBQUcsQ0FBcUI7UUFDekQsT0FBT3pCLFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNc0QseUJBQXlCLE9BQU9DO0lBQzNDLElBQUk7UUFDRixNQUFNeEQsV0FBVyxNQUFNZixVQUFVZ0MsSUFBSSxDQUFtQix3QkFBd0J1QztRQUNoRixPQUFPeEQsU0FBU1ksSUFBSTtJQUN0QixFQUFFLE9BQU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU13RCwwQkFBMEIsT0FBT3hCO0lBQzVDLElBQUk7UUFDRixNQUFNakMsV0FBVyxNQUFNZixVQUFVd0MsR0FBRyxDQUFtQix3QkFBMkIsT0FBSFE7UUFDL0UsT0FBT2pDLFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNeUQseUJBQXlCLE9BQU96QixJQUFZdUI7SUFDdkQsSUFBSTtRQUNGLE1BQU14RCxXQUFXLE1BQU1mLFVBQVUyQyxHQUFHLENBQW1CLHdCQUEyQixPQUFISyxLQUFNdUI7UUFDckYsT0FBT3hELFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNMEQseUJBQXlCLE9BQU8xQjtJQUMzQyxJQUFJO1FBQ0YsTUFBTWhELFVBQVUyRSxNQUFNLENBQUMsd0JBQTJCLE9BQUgzQjtJQUNqRCxFQUFFLE9BQU9oQyxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNNEQsK0JBQStCLE9BQU9DO0lBQ2pELElBQUk7UUFDRixNQUFNOUQsV0FBVyxNQUFNZixVQUFVd0MsR0FBRyxDQUFnQiw2QkFBeUMsT0FBWnFDO1FBQ2pGLE9BQU85RCxTQUFTWSxJQUFJO0lBQ3RCLEVBQUUsT0FBT1gsT0FBTztRQUNkLE1BQU1VLGVBQWVWO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTThELHdCQUF3QjtJQUNuQyxJQUFJO1FBQ0YsTUFBTS9ELFdBQVcsTUFBTWYsVUFBVXdDLEdBQUcsQ0FBZ0I7UUFDcEQsT0FBT3pCLFNBQVNZLElBQUk7SUFDdEIsRUFBRSxPQUFPWCxPQUFPO1FBQ2QsTUFBTVUsZUFBZVY7SUFDdkI7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNK0QscUJBQXFCLE9BQU9DO0lBQ3ZDLElBQUk7UUFDRixNQUFNaEYsVUFBVWdDLElBQUksQ0FBQyxjQUF3QixPQUFWZ0Q7SUFDckMsRUFBRSxPQUFPaEUsT0FBTztRQUNkLE1BQU1VLGVBQWVWO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTWlFLHdCQUF3QixPQUFPRDtJQUMxQyxJQUFJO1FBQ0YsTUFBTWhGLFVBQVUyRSxNQUFNLENBQUMsY0FBd0IsT0FBVks7SUFDdkMsRUFBRSxPQUFPaEUsT0FBTztRQUNkLE1BQU1VLGVBQWVWO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTWtFLGlCQUFpQixPQUFPQztJQUNuQyxJQUFJO1FBQ0YsaUVBQWlFO1FBQ2pFLG1HQUFtRztRQUNuRyx5REFBeUQ7UUFDekQsdUZBQXVGO1FBQ3ZGLE1BQU1uRixVQUFVZ0MsSUFBSSxDQUFDLDBCQUF3QyxPQUFkbUQ7SUFDakQsRUFBRSxPQUFPbkUsT0FBTztRQUNkLE1BQU1VLGVBQWVWO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTW9FLDZCQUE2QjtRQUN4Q3ZDLHdFQUFlLEdBQ2ZDLHdFQUFlO0lBRWYsSUFBSTtRQUNGLE1BQU0vQixXQUFXLE1BQU1mLFVBQVV3QyxHQUFHLENBQ2xDLDhCQUEyQ00sT0FBYkQsTUFBSyxVQUFhLE9BQUxDO1FBRTdDLE9BQU8vQixTQUFTWSxJQUFJO0lBQ3RCLEVBQUUsT0FBT1gsT0FBTztRQUNkLE1BQU1VLGVBQWVWO0lBQ3ZCO0FBQ0YsRUFBRTtBQUVLLE1BQU1xRSxxQkFBcUI7UUFDaEN4Qyx3RUFBZSxHQUNmQyx3RUFBZTtJQUVmLElBQUk7UUFDRixNQUFNL0IsV0FBVyxNQUFNZixVQUFVd0MsR0FBRyxDQUNsQyxtQkFBZ0NNLE9BQWJELE1BQUssVUFBYSxPQUFMQztRQUVsQyxPQUFPL0IsU0FBU1ksSUFBSTtJQUN0QixFQUFFLE9BQU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS1zZXJ2aWNlcy50cz9jMDRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2VydmnDp29zIGRlIEFQSSBwYXJhIG8gc2lzdGVtYSBTaW1wbGVcbiAqIEVzdGUgYXJxdWl2byBjb250w6ltIGFzIGZ1bsOnw7VlcyBwYXJhIGludGVyYWdpciBjb20gbyBiYWNrZW5kXG4gKi9cblxuLy8gRmlyc3QgaW5zdGFsbCBheGlvczogbnBtIGluc3RhbGwgYXhpb3MgQHR5cGVzL2F4aW9zXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHR5cGUgeyBBeGlvc0Vycm9yLCBBeGlvc1JlcXVlc3RDb25maWcsIEludGVybmFsQXhpb3NSZXF1ZXN0Q29uZmlnIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgQVBJX0JBU0UsIERFRkFVTFRfSEVBREVSUywgREVGQVVMVF9USU1FT1VUIH0gZnJvbSAnLi9hcGktY29uZmlnJztcbmltcG9ydCB7XG4gIEFwaUVycm9yLFxuICBBdXRoUmVxdWVzdCxcbiAgQXV0aFJlc3BvbnNlLFxuICBDaWRhZGFvUmVxdWVzdCxcbiAgQ2lkYWRhb1Jlc3BvbnNlLFxuICBEYXNoYm9hcmRJdGVtLFxuICBQYWdpbmF0ZWRSZXNwb25zZSxcbiAgUGVkaWRvUmVxdWVzdCxcbiAgUGVkaWRvUmVzcG9uc2UsXG4gIFJlcXVlc3RTdGF0dXMsXG4gIFJlcXVlc3RUeXBlLFxuICBUaXBvU2VydmljbyxcbiAgVXN1YXJpb1JlcXVlc3QsXG4gIFVzdWFyaW9SZXNwb25zZVxufSBmcm9tICcuL3R5cGVzJztcblxuLy8gQ2xpZW50ZSBheGlvcyBjb25maWd1cmFkb1xuY29uc3QgYXBpQ2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogQVBJX0JBU0UsXG4gIHRpbWVvdXQ6IERFRkFVTFRfVElNRU9VVCxcbiAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxufSk7XG5cbi8vIEludGVyY2VwdG9yIHBhcmEgYWRpY2lvbmFyIHRva2VuIGRlIGF1dGVudGljYcOnw6NvXG5hcGlDbGllbnQuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKChjb25maWc6IEludGVybmFsQXhpb3NSZXF1ZXN0Q29uZmlnKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE7Do28gYWRpY2lvbmFyIHRva2VuIGRlIGF1dGVudGljYcOnw6NvIHBhcmEgYSByb3RhIGRlIGxvZ2luIG91IHJlZ2lzdHJvXG4gICAgaWYgKGNvbmZpZy51cmwgPT09ICcvYXV0aC9sb2dpbicgfHwgY29uZmlnLnVybCA9PT0gJy9hdXRoL3JlZ2lzdGVyJykge1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgaWYgKCFjb25maWcuaGVhZGVycykgY29uZmlnLmhlYWRlcnMgPSBuZXcgYXhpb3MuQXhpb3NIZWFkZXJzKCk7XG4gICAgICBjb25maWcuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWc7XG59KTtcblxuLy8gSW50ZXJjZXB0b3IgcGFyYSB0cmF0YXIgcmVzcG9zdGFzIGdsb2JhaXMsIGluY2x1aW5kbyBlcnJvcyBkZSBhdXRlbnRpY2HDp8Ojb1xuYXBpQ2xpZW50LmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsIC8vIFBhc3NhIGFzIHJlc3Bvc3RhcyBkZSBzdWNlc3NvIGRpcmV0YW1lbnRlXG4gIChlcnJvcjogQXhpb3NFcnJvcikgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgOiAnJztcbiAgICAvLyBWZXJpZmljYSBzZSBvIGVycm8gw6kgNDAxIChOw6NvIEF1dG9yaXphZG8pIE9VIDQwMyAoUHJvaWJpZG8pXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlICYmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQwMykpIHtcbiAgICAgIC8vIEV2aXRhIGxvb3BzIGRlIHJlZGlyZWNpb25hbWVudG8gc2UgasOhIGVzdGl2ZXIgbmEgcMOhZ2luYSBkZSBsb2dpbiBvdSByZWdpc3Ryb1xuICAgICAgaWYgKGN1cnJlbnRQYXRoICYmIGN1cnJlbnRQYXRoICE9PSAnL2xvZ2luJyAmJiBjdXJyZW50UGF0aCAhPT0gJy9yZWdpc3RlcicpIHtcbiAgICAgICAgbG9nb3V0KCk7IC8vIExpbXBhIG8gdG9rZW4gZSBjb29raWVzXG4gICAgICAgIC8vIFJlZGlyZWNpb25hIHBhcmEgYSBww6FnaW5hIGRlIGxvZ2luXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9sb2dpbic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0b3JuYSB1bWEgcHJvbWVzc2EgcXVlIG51bmNhIHJlc29sdmUgcGFyYSBldml0YXIgcXVlIG8gY2hhbWFkb3Igb3JpZ2luYWxcbiAgICAgICAgLy8gdGVudGUgYXR1YWxpemFyIG8gZXN0YWRvIGRlIHVtIGNvbXBvbmVudGUgZGVzbW9udGFkby5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUGFyYSB0b2RvcyBvcyBvdXRyb3MgZXJyb3MsIG91IHNlIGrDoSBlc3RpdmVyIGVtIC9sb2dpbiBvdSAvcmVnaXN0ZXIsIHJlamVpdGEgYSBwcm9tZXNzYVxuICAgIC8vIHBhcmEgcXVlIG8gdHJhdGFtZW50byBkZSBlcnJvIGxvY2FsIHBvc3NhIG9jb3JyZXIuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBUcmF0YSBlcnJvcyBkYSBBUEkgZGUgZm9ybWEgcGFkcm9uaXphZGFcbiAqL1xuY29uc3QgaGFuZGxlQXBpRXJyb3IgPSAoZXJyb3I6IEF4aW9zRXJyb3IpOiBBcGlFcnJvciA9PiB7XG4gIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgIC8vIE8gc2Vydmlkb3IgcmVzcG9uZGV1IGNvbSB1bSBzdGF0dXMgZGUgZXJyb1xuICAgIGNvbnN0IGRhdGEgPSBlcnJvci5yZXNwb25zZS5kYXRhIGFzIGFueTtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogZGF0YS5tZXNzYWdlIHx8IGRhdGEuZXJyb3IgfHwgJ0Vycm8gZGVzY29uaGVjaWRvJyxcbiAgICAgIHN0YXR1czogZXJyb3IucmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgdGltZXN0YW1wOiBkYXRhLnRpbWVzdGFtcCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGVycm9yLnJlcXVlc3QpIHtcbiAgICAvLyBBIHJlcXVpc2nDp8OjbyBmb2kgZmVpdGEgbWFzIG7Do28gaG91dmUgcmVzcG9zdGFcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogJ07Do28gZm9pIHBvc3PDrXZlbCBjb25lY3RhciBhbyBzZXJ2aWRvcicsXG4gICAgICBzdGF0dXM6IDAsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFcnJvIGFvIGNvbmZpZ3VyYXIgYSByZXF1aXNpw6fDo29cbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCAnRXJybyBhbyBwcm9jZXNzYXIgYSByZXF1aXNpw6fDo28nLFxuICAgICAgc3RhdHVzOiAwLFxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogUmVhbGl6YSBsb2dpbiBubyBzaXN0ZW1hXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dpbiA9IGFzeW5jIChjcmVkZW50aWFsczogQXV0aFJlcXVlc3QpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3Q8QXV0aFJlc3BvbnNlPignL2F1dGgvbG9naW4nLCBjcmVkZW50aWFscyk7XG4gICAgLy8gQXJtYXplbmEgbyB0b2tlbiBwYXJhIHVzbyBmdXR1cm9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2tlbicsIHJlc3BvbnNlLmRhdGEudG9rZW4pO1xuICAgICAgLy8gU2FsdmEgbyB0b2tlbiBjb21vIGNvb2tpZVxuICAgICAgZG9jdW1lbnQuY29va2llID0gYHRva2VuPSR7cmVzcG9uc2UuZGF0YS50b2tlbn07IHBhdGg9LzsgbWF4LWFnZT0kezYwICogNjAgKiAyNCAqIDd9OyBTYW1lU2l0ZT1MYXhgOyAvLyBFeHBpcmEgZW0gNyBkaWFzXG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlYWxpemEgbG9nb3V0IGRvIHNpc3RlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ291dCA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Rva2VuJyk7XG4gICAgLy8gUmVtb3ZlIG8gY29va2llIGRvIHRva2VuXG4gICAgZG9jdW1lbnQuY29va2llID0gJ3Rva2VuPTsgcGF0aD0vOyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UOyBTYW1lU2l0ZT1MYXgnO1xuICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdHJhIHVtIG5vdm8gdXN1w6FyaW9cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyVXNlciA9IGFzeW5jICh1c2VyOiBVc3VhcmlvUmVxdWVzdCk6IFByb21pc2U8VXN1YXJpb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdDxVc3VhcmlvUmVzcG9uc2U+KCcvYXV0aC9yZWdpc3RlcicsIHVzZXIpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIE9idMOpbSBvIHVzdcOhcmlvIGF0dWFsXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50VXNlciA9IGFzeW5jICgpOiBQcm9taXNlPFVzdWFyaW9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxVc3VhcmlvUmVzcG9uc2U+KCcvdXNlcnMvbWUnKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHVhbGl6YSBvIHBlcmZpbCBkbyB1c3XDoXJpbyBhdHVhbFxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlVXNlclByb2ZpbGUgPSBhc3luYyAodXNlckRhdGE6IFBhcnRpYWw8VXN1YXJpb1JlcXVlc3Q+KTogUHJvbWlzZTxVc3VhcmlvUmVzcG9uc2U+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQ8VXN1YXJpb1Jlc3BvbnNlPignL3VzZXJzL21lJywgdXNlckRhdGEpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIExpc3RhIHRvZG9zIG9zIGNpZGFkw6NvcyAocGFnaW5hZG8pXG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0Q2lkYWRhb3MgPSBhc3luYyAoXG4gIHBhZ2U6IG51bWJlciA9IDAsXG4gIHNpemU6IG51bWJlciA9IDEwXG4pOiBQcm9taXNlPFBhZ2luYXRlZFJlc3BvbnNlPENpZGFkYW9SZXNwb25zZT4+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQ8UGFnaW5hdGVkUmVzcG9uc2U8Q2lkYWRhb1Jlc3BvbnNlPj4oXG4gICAgICBgL2NpZGFkYW9zP3BhZ2U9JHtwYWdlfSZzaXplPSR7c2l6ZX1gXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnTDqW0gdW0gY2lkYWTDo28gcGVsbyBJRFxuICovXG5leHBvcnQgY29uc3QgZ2V0Q2lkYWRhb0J5SWQgPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8Q2lkYWRhb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PENpZGFkYW9SZXNwb25zZT4oYC9jaWRhZGFvcy8ke2lkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIE9idMOpbSB1bSBjaWRhZMOjbyBwZWxvIGRvY3VtZW50b1xuICovXG5leHBvcnQgY29uc3QgZ2V0Q2lkYWRhb0J5RG9jdW1lbnRvID0gYXN5bmMgKFxuICB0aXBvRG9jdW1lbnRvOiBzdHJpbmcsXG4gIG51bWVyb0RvY3VtZW50bzogc3RyaW5nXG4pOiBQcm9taXNlPENpZGFkYW9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxDaWRhZGFvUmVzcG9uc2U+KFxuICAgICAgYC9jaWRhZGFvcy9kb2N1bWVudG8/dGlwb0RvY3VtZW50bz0ke3RpcG9Eb2N1bWVudG99Jm51bWVyb0RvY3VtZW50bz0ke251bWVyb0RvY3VtZW50b31gXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmlhIHVtIG5vdm8gY2lkYWTDo29cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNpZGFkYW8gPSBhc3luYyAoY2lkYWRhbzogQ2lkYWRhb1JlcXVlc3QpOiBQcm9taXNlPENpZGFkYW9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3Q8Q2lkYWRhb1Jlc3BvbnNlPignL2NpZGFkYW9zJywgY2lkYWRhbyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQXR1YWxpemEgdW0gY2lkYWTDo28gZXhpc3RlbnRlXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVDaWRhZGFvID0gYXN5bmMgKFxuICBpZDogc3RyaW5nLFxuICBjaWRhZGFvOiBDaWRhZGFvUmVxdWVzdFxuKTogUHJvbWlzZTxDaWRhZGFvUmVzcG9uc2U+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQ8Q2lkYWRhb1Jlc3BvbnNlPihgL2NpZGFkYW9zLyR7aWR9YCwgY2lkYWRhbyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogTGlzdGEgdG9kb3Mgb3MgcGVkaWRvcyAocGFnaW5hZG8pXG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0UGVkaWRvcyA9IGFzeW5jIChcbiAgcGFnZTogbnVtYmVyID0gMCxcbiAgc2l6ZTogbnVtYmVyID0gMTBcbik6IFByb21pc2U8UGFnaW5hdGVkUmVzcG9uc2U8UGVkaWRvUmVzcG9uc2U+PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFBhZ2luYXRlZFJlc3BvbnNlPFBlZGlkb1Jlc3BvbnNlPj4oXG4gICAgICBgL3BlZGlkb3M/cGFnZT0ke3BhZ2V9JnNpemU9JHtzaXplfWBcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIE9idMOpbSB1bSBwZWRpZG8gcGVsbyBJRFxuICovXG5leHBvcnQgY29uc3QgZ2V0UGVkaWRvQnlJZCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxQZWRpZG9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxQZWRpZG9SZXNwb25zZT4oYC9wZWRpZG9zLyR7aWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogT2J0w6ltIHVtIHBlZGlkbyBwZWxvIGPDs2RpZ28gZGUgYWNvbXBhbmhhbWVudG9cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFBlZGlkb0J5Q29kaWdvID0gYXN5bmMgKGNvZGlnbzogc3RyaW5nKTogUHJvbWlzZTxQZWRpZG9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxQZWRpZG9SZXNwb25zZT4oYC9wZWRpZG9zL2NvZGlnby8ke2NvZGlnb31gKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMaXN0YSBwZWRpZG9zIHBvciBjaWRhZMOjbyAocGFnaW5hZG8pXG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0UGVkaWRvc0J5Q2lkYWRhbyA9IGFzeW5jIChcbiAgY2lkYWRhb0lkOiBzdHJpbmcsXG4gIHBhZ2U6IG51bWJlciA9IDAsXG4gIHNpemU6IG51bWJlciA9IDEwXG4pOiBQcm9taXNlPFBhZ2luYXRlZFJlc3BvbnNlPFBlZGlkb1Jlc3BvbnNlPj4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxQYWdpbmF0ZWRSZXNwb25zZTxQZWRpZG9SZXNwb25zZT4+KFxuICAgICAgYC9wZWRpZG9zL2NpZGFkYW8vJHtjaWRhZGFvSWR9P3BhZ2U9JHtwYWdlfSZzaXplPSR7c2l6ZX1gXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmlhIHVtIG5vdm8gcGVkaWRvXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVQZWRpZG8gPSBhc3luYyAocGVkaWRvOiBQZWRpZG9SZXF1ZXN0KTogUHJvbWlzZTxQZWRpZG9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3Q8UGVkaWRvUmVzcG9uc2U+KCcvcGVkaWRvcycsIHBlZGlkbyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQXR1YWxpemEgbyBzdGF0dXMgZGUgdW0gcGVkaWRvXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVQZWRpZG9TdGF0dXMgPSBhc3luYyAoXG4gIGlkOiBzdHJpbmcsXG4gIHN0YXR1c0lkOiBudW1iZXJcbik6IFByb21pc2U8UGVkaWRvUmVzcG9uc2U+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wYXRjaDxQZWRpZG9SZXNwb25zZT4oYC9wZWRpZG9zLyR7aWR9L3N0YXR1cy8ke3N0YXR1c0lkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIExpc3RhIG9zIHRpcG9zIGRlIHNlcnZpw6dvcyBkaXNwb27DrXZlaXNcbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RUaXBvc1NlcnZpY29zID0gYXN5bmMgKCk6IFByb21pc2U8VGlwb1NlcnZpY29bXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxUaXBvU2Vydmljb1tdPignL3RpcG9zLXNlcnZpY29zJyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JpYSB1bSBub3ZvIHRpcG8gZGUgc2VydmnDp29cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRpcG9TZXJ2aWNvID0gYXN5bmMgKHNlcnZpY2VEYXRhOiBPbWl0PFRpcG9TZXJ2aWNvLCAnaWQnPik6IFByb21pc2U8VGlwb1NlcnZpY28+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0PFRpcG9TZXJ2aWNvPignL3RpcG9zLXNlcnZpY29zJywgc2VydmljZURhdGEpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vLyBGdW7Dp8O1ZXMgQ1JVRCBwYXJhIENhdGVnb3JpYVNlcnZpY29cbi8qKlxuICogTGlzdGEgdG9kYXMgYXMgY2F0ZWdvcmlhcyBkZSBzZXJ2acOnb3NcbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RDYXRlZ29yaWFzU2Vydmljb3MgPSBhc3luYyAoKTogUHJvbWlzZTxDYXRlZ29yaWFTZXJ2aWNvW10+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQ8Q2F0ZWdvcmlhU2Vydmljb1tdPignL2NhdGVnb3JpYXMtc2Vydmljb3MnKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmlhIHVtYSBub3ZhIGNhdGVnb3JpYSBkZSBzZXJ2acOnb1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ2F0ZWdvcmlhU2VydmljbyA9IGFzeW5jIChjYXRlZ29yaWFEYXRhOiBPbWl0PENhdGVnb3JpYVNlcnZpY28sICdpZCc+KTogUHJvbWlzZTxDYXRlZ29yaWFTZXJ2aWNvPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdDxDYXRlZ29yaWFTZXJ2aWNvPignL2NhdGVnb3JpYXMtc2Vydmljb3MnLCBjYXRlZ29yaWFEYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnTDqW0gdW1hIGNhdGVnb3JpYSBkZSBzZXJ2acOnbyBwZWxvIElEXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDYXRlZ29yaWFTZXJ2aWNvQnlJZCA9IGFzeW5jIChpZDogbnVtYmVyKTogUHJvbWlzZTxDYXRlZ29yaWFTZXJ2aWNvPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PENhdGVnb3JpYVNlcnZpY28+KGAvY2F0ZWdvcmlhcy1zZXJ2aWNvcy8ke2lkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dWFsaXphIHVtYSBjYXRlZ29yaWEgZGUgc2VydmnDp28gZXhpc3RlbnRlXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVDYXRlZ29yaWFTZXJ2aWNvID0gYXN5bmMgKGlkOiBudW1iZXIsIGNhdGVnb3JpYURhdGE6IFBhcnRpYWw8Q2F0ZWdvcmlhU2Vydmljbz4pOiBQcm9taXNlPENhdGVnb3JpYVNlcnZpY28+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQ8Q2F0ZWdvcmlhU2Vydmljbz4oYC9jYXRlZ29yaWFzLXNlcnZpY29zLyR7aWR9YCwgY2F0ZWdvcmlhRGF0YSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogRGVsZXRhIHVtYSBjYXRlZ29yaWEgZGUgc2VydmnDp29cbiAqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZUNhdGVnb3JpYVNlcnZpY28gPSBhc3luYyAoaWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9jYXRlZ29yaWFzLXNlcnZpY29zLyR7aWR9YCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogTGlzdGEgb3MgdGlwb3MgZGUgc2VydmnDp29zIHBvciBjYXRlZ29yaWEgSURcbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RUaXBvc1NlcnZpY29zQnlDYXRlZ29yaWEgPSBhc3luYyAoY2F0ZWdvcmlhSWQ6IG51bWJlcik6IFByb21pc2U8VGlwb1NlcnZpY29bXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxUaXBvU2Vydmljb1tdPihgL3RpcG9zLXNlcnZpY29zL2NhdGVnb3JpYS8ke2NhdGVnb3JpYUlkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIExpc3RhIG9zIHNlcnZpw6dvcyBmYXZvcml0b3MgZG8gdXN1w6FyaW9cbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RTZXJ2aWNvc0Zhdm9yaXRvcyA9IGFzeW5jICgpOiBQcm9taXNlPFRpcG9TZXJ2aWNvW10+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQ8VGlwb1NlcnZpY29bXT4oJy9mYXZvcml0b3MnKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGljaW9uYSB1bSBzZXJ2acOnbyBhb3MgZmF2b3JpdG9zXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRTZXJ2aWNvRmF2b3JpdG8gPSBhc3luYyAoc2Vydmljb0lkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBhcGlDbGllbnQucG9zdChgL2Zhdm9yaXRvcy8ke3NlcnZpY29JZH1gKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgdW0gc2VydmnDp28gZG9zIGZhdm9yaXRvc1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlU2Vydmljb0Zhdm9yaXRvID0gYXN5bmMgKHNlcnZpY29JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgYXBpQ2xpZW50LmRlbGV0ZShgL2Zhdm9yaXRvcy8ke3NlcnZpY29JZH1gKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGljaW9uYSBvdSByZW1vdmUgdW0gc2VydmnDp28gZG9zIGZhdm9yaXRvcyBkbyB1c3XDoXJpbyBhdHVhbFxuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlRmF2b3JpdG8gPSBhc3luYyAodGlwb1NlcnZpY29JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gTyBlbmRwb2ludCBleGF0byBwb2RlIHZhcmlhciwgYWp1c3RlIGNvbmZvcm1lIGEgQVBJIGRvIGJhY2tlbmRcbiAgICAvLyBQb2RlIHNlciB1bSBQT1NUIHBhcmEgYWRpY2lvbmFyIGUgdW0gREVMRVRFIHBhcmEgcmVtb3Zlciwgb3UgdW0gw7puaWNvIGVuZHBvaW50IHF1ZSBmYXogbyB0b2dnbGUuXG4gICAgLy8gQXF1aSwgdmFtb3MgYXNzdW1pciB1bSBlbmRwb2ludCBQT1NUIHF1ZSBmYXogbyB0b2dnbGUuXG4gICAgLy8gU2UgbyBiYWNrZW5kIHJldG9ybmFyIG9zIGZhdm9yaXRvcyBhdHVhbGl6YWRvcywgdm9jw6ogcG9kZSBhanVzdGFyIG8gdGlwbyBkZSByZXRvcm5vLlxuICAgIGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvdXN1YXJpb3MvbWUvZmF2b3JpdG9zLyR7dGlwb1NlcnZpY29JZH1gKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMaXN0YSBvcyBpdGVucyBkbyBkYXNoYm9hcmQgKHBhZ2luYWRvKVxuICovXG5leHBvcnQgY29uc3QgbGlzdFBlZGlkb3NEb1VzdWFyaW9Mb2dhZG8gPSBhc3luYyAoXG4gIHBhZ2U6IG51bWJlciA9IDAsXG4gIHNpemU6IG51bWJlciA9IDEwXG4pOiBQcm9taXNlPFBhZ2luYXRlZFJlc3BvbnNlPFBlZGlkb1Jlc3BvbnNlPj4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxQYWdpbmF0ZWRSZXNwb25zZTxQZWRpZG9SZXNwb25zZT4+KFxuICAgICAgYC9wZWRpZG9zL21ldXMtcGVkaWRvcz9wYWdlPSR7cGFnZX0mc2l6ZT0ke3NpemV9YFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBsaXN0RGFzaGJvYXJkSXRlbXMgPSBhc3luYyAoXG4gIHBhZ2U6IG51bWJlciA9IDAsXG4gIHNpemU6IG51bWJlciA9IDEwXG4pOiBQcm9taXNlPFBhZ2luYXRlZFJlc3BvbnNlPERhc2hib2FyZEl0ZW0+PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFBhZ2luYXRlZFJlc3BvbnNlPERhc2hib2FyZEl0ZW0+PihcbiAgICAgIGAvZGFzaGJvYXJkP3BhZ2U9JHtwYWdlfSZzaXplPSR7c2l6ZX1gXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLy8gUmUtZXhwb3J0YXIgb3MgdGlwb3MgcGFyYSBmYWNpbGl0YXIgbyB1c29cbmV4cG9ydCB0eXBlIHtcbiAgQXBpRXJyb3IsXG4gIEF1dGhSZXF1ZXN0LFxuICBBdXRoUmVzcG9uc2UsXG4gIENpZGFkYW9SZXF1ZXN0LFxuICBDaWRhZGFvUmVzcG9uc2UsXG4gIERhc2hib2FyZEl0ZW0sXG4gIFBhZ2luYXRlZFJlc3BvbnNlLFxuICBQZWRpZG9SZXF1ZXN0LFxuICBQZWRpZG9SZXNwb25zZSxcbiAgUmVxdWVzdFN0YXR1cyxcbiAgUmVxdWVzdFR5cGUsXG4gIFRpcG9TZXJ2aWNvLFxuICBVc3VhcmlvUmVxdWVzdCxcbiAgVXN1YXJpb1Jlc3BvbnNlXG59O1xuXG4iXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfQkFTRSIsIkRFRkFVTFRfSEVBREVSUyIsIkRFRkFVTFRfVElNRU9VVCIsImFwaUNsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJ0aW1lb3V0IiwiaGVhZGVycyIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ1cmwiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJBeGlvc0hlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwicmVzcG9uc2UiLCJlcnJvciIsImN1cnJlbnRQYXRoIiwid2luZG93IiwibG9jYXRpb24iLCJwYXRobmFtZSIsInN0YXR1cyIsImxvZ291dCIsImhyZWYiLCJQcm9taXNlIiwicmVqZWN0IiwiaGFuZGxlQXBpRXJyb3IiLCJkYXRhIiwibWVzc2FnZSIsInRpbWVzdGFtcCIsImxvZ2luIiwiY3JlZGVudGlhbHMiLCJwb3N0Iiwic2V0SXRlbSIsImRvY3VtZW50IiwiY29va2llIiwicmVtb3ZlSXRlbSIsInJlZ2lzdGVyVXNlciIsInVzZXIiLCJnZXRDdXJyZW50VXNlciIsImdldCIsInVwZGF0ZVVzZXJQcm9maWxlIiwidXNlckRhdGEiLCJwdXQiLCJsaXN0Q2lkYWRhb3MiLCJwYWdlIiwic2l6ZSIsImdldENpZGFkYW9CeUlkIiwiaWQiLCJnZXRDaWRhZGFvQnlEb2N1bWVudG8iLCJ0aXBvRG9jdW1lbnRvIiwibnVtZXJvRG9jdW1lbnRvIiwiY3JlYXRlQ2lkYWRhbyIsImNpZGFkYW8iLCJ1cGRhdGVDaWRhZGFvIiwibGlzdFBlZGlkb3MiLCJnZXRQZWRpZG9CeUlkIiwiZ2V0UGVkaWRvQnlDb2RpZ28iLCJjb2RpZ28iLCJsaXN0UGVkaWRvc0J5Q2lkYWRhbyIsImNpZGFkYW9JZCIsImNyZWF0ZVBlZGlkbyIsInBlZGlkbyIsInVwZGF0ZVBlZGlkb1N0YXR1cyIsInN0YXR1c0lkIiwicGF0Y2giLCJsaXN0VGlwb3NTZXJ2aWNvcyIsImNyZWF0ZVRpcG9TZXJ2aWNvIiwic2VydmljZURhdGEiLCJsaXN0Q2F0ZWdvcmlhc1NlcnZpY29zIiwiY3JlYXRlQ2F0ZWdvcmlhU2VydmljbyIsImNhdGVnb3JpYURhdGEiLCJnZXRDYXRlZ29yaWFTZXJ2aWNvQnlJZCIsInVwZGF0ZUNhdGVnb3JpYVNlcnZpY28iLCJkZWxldGVDYXRlZ29yaWFTZXJ2aWNvIiwiZGVsZXRlIiwibGlzdFRpcG9zU2Vydmljb3NCeUNhdGVnb3JpYSIsImNhdGVnb3JpYUlkIiwibGlzdFNlcnZpY29zRmF2b3JpdG9zIiwiYWRkU2Vydmljb0Zhdm9yaXRvIiwic2Vydmljb0lkIiwicmVtb3ZlU2Vydmljb0Zhdm9yaXRvIiwidG9nZ2xlRmF2b3JpdG8iLCJ0aXBvU2Vydmljb0lkIiwibGlzdFBlZGlkb3NEb1VzdWFyaW9Mb2dhZG8iLCJsaXN0RGFzaGJvYXJkSXRlbXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-services.ts\n"));

/***/ })

});
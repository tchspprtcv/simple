"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/new-request/page",{

/***/ "(app-pages-browser)/./lib/api-services.ts":
/*!*****************************!*\
  !*** ./lib/api-services.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addServicoFavorito: function() { return /* binding */ addServicoFavorito; },\n/* harmony export */   createCidadao: function() { return /* binding */ createCidadao; },\n/* harmony export */   createPedido: function() { return /* binding */ createPedido; },\n/* harmony export */   createTipoServico: function() { return /* binding */ createTipoServico; },\n/* harmony export */   getCidadaoByDocumento: function() { return /* binding */ getCidadaoByDocumento; },\n/* harmony export */   getCidadaoById: function() { return /* binding */ getCidadaoById; },\n/* harmony export */   getCurrentUser: function() { return /* binding */ getCurrentUser; },\n/* harmony export */   getPedidoByCodigo: function() { return /* binding */ getPedidoByCodigo; },\n/* harmony export */   getPedidoById: function() { return /* binding */ getPedidoById; },\n/* harmony export */   listCidadaos: function() { return /* binding */ listCidadaos; },\n/* harmony export */   listDashboardItems: function() { return /* binding */ listDashboardItems; },\n/* harmony export */   listPedidos: function() { return /* binding */ listPedidos; },\n/* harmony export */   listPedidosByCidadao: function() { return /* binding */ listPedidosByCidadao; },\n/* harmony export */   listPedidosDoUsuarioLogado: function() { return /* binding */ listPedidosDoUsuarioLogado; },\n/* harmony export */   listServicosFavoritos: function() { return /* binding */ listServicosFavoritos; },\n/* harmony export */   listTiposServicos: function() { return /* binding */ listTiposServicos; },\n/* harmony export */   listTiposServicosByCategoria: function() { return /* binding */ listTiposServicosByCategoria; },\n/* harmony export */   login: function() { return /* binding */ login; },\n/* harmony export */   logout: function() { return /* binding */ logout; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   removeServicoFavorito: function() { return /* binding */ removeServicoFavorito; },\n/* harmony export */   toggleFavorito: function() { return /* binding */ toggleFavorito; },\n/* harmony export */   updateCidadao: function() { return /* binding */ updateCidadao; },\n/* harmony export */   updatePedidoStatus: function() { return /* binding */ updatePedidoStatus; },\n/* harmony export */   updateUserProfile: function() { return /* binding */ updateUserProfile; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _api_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api-config */ \"(app-pages-browser)/./lib/api-config.ts\");\n/**\n * Serviços de API para o sistema Simple\n * Este arquivo contém as funções para interagir com o backend\n */ // First install axios: npm install axios @types/axios\n\n\n// Cliente axios configurado\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n    baseURL: _api_config__WEBPACK_IMPORTED_MODULE_0__.API_BASE,\n    timeout: _api_config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT,\n    headers: _api_config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS\n});\n// Interceptor para adicionar token de autenticação\napiClient.interceptors.request.use((config)=>{\n    if (true) {\n        // Não adicionar token de autenticação para a rota de login ou registro\n        if (config.url === \"/auth/login\" || config.url === \"/auth/register\") {\n            return config;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (token) {\n            if (!config.headers) config.headers = new axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].AxiosHeaders();\n            config.headers.Authorization = \"Bearer \".concat(token);\n        }\n    }\n    return config;\n});\n// Interceptor para tratar respostas globais, incluindo erros de autenticação\napiClient.interceptors.response.use((response)=>response, (error)=>{\n    const currentPath =  true ? window.location.pathname : 0;\n    // Verifica se o erro é 401 (Não Autorizado) OU 403 (Proibido)\n    if (error.response && (error.response.status === 401 || error.response.status === 403)) {\n        // Evita loops de redirecionamento se já estiver na página de login ou registro\n        if (currentPath && currentPath !== \"/login\" && currentPath !== \"/register\") {\n            logout(); // Limpa o token e cookies\n            // Redireciona para a página de login\n            if (true) {\n                window.location.href = \"/login\";\n            }\n            // Retorna uma promessa que nunca resolve para evitar que o chamador original\n            // tente atualizar o estado de um componente desmontado.\n            return new Promise(()=>{});\n        }\n    }\n    // Para todos os outros erros, ou se já estiver em /login ou /register, rejeita a promessa\n    // para que o tratamento de erro local possa ocorrer.\n    return Promise.reject(error);\n});\n/**\n * Trata erros da API de forma padronizada\n */ const handleApiError = (error)=>{\n    if (error.response) {\n        // O servidor respondeu com um status de erro\n        const data = error.response.data;\n        return {\n            message: data.message || data.error || \"Erro desconhecido\",\n            status: error.response.status,\n            timestamp: data.timestamp\n        };\n    } else if (error.request) {\n        // A requisição foi feita mas não houve resposta\n        return {\n            message: \"N\\xe3o foi poss\\xedvel conectar ao servidor\",\n            status: 0\n        };\n    } else {\n        // Erro ao configurar a requisição\n        return {\n            message: error.message || \"Erro ao processar a requisi\\xe7\\xe3o\",\n            status: 0\n        };\n    }\n};\n/**\n * Realiza login no sistema\n */ const login = async (credentials)=>{\n    try {\n        const response = await apiClient.post(\"/auth/login\", credentials);\n        // Armazena o token para uso futuro\n        if (true) {\n            localStorage.setItem(\"token\", response.data.token);\n            // Salva o token como cookie\n            document.cookie = \"token=\".concat(response.data.token, \"; path=/; max-age=\").concat(60 * 60 * 24 * 7, \"; SameSite=Lax\"); // Expira em 7 dias\n        }\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Realiza logout do sistema\n */ const logout = ()=>{\n    if (true) {\n        localStorage.removeItem(\"token\");\n        // Remove o cookie do token\n        document.cookie = \"token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Lax\";\n    }\n};\n/**\n * Registra um novo usuário\n */ const registerUser = async (user)=>{\n    try {\n        const response = await apiClient.post(\"/auth/register\", user);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém o usuário atual\n */ const getCurrentUser = async ()=>{\n    try {\n        const response = await apiClient.get(\"/users/me\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza o perfil do usuário atual\n */ const updateUserProfile = async (userData)=>{\n    try {\n        const response = await apiClient.put(\"/users/me\", userData);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista todos os cidadãos (paginado)\n */ const listCidadaos = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/cidadaos?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um cidadão pelo ID\n */ const getCidadaoById = async (id)=>{\n    try {\n        const response = await apiClient.get(\"/cidadaos/\".concat(id));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um cidadão pelo documento\n */ const getCidadaoByDocumento = async (tipoDocumento, numeroDocumento)=>{\n    try {\n        const response = await apiClient.get(\"/cidadaos/documento?tipoDocumento=\".concat(tipoDocumento, \"&numeroDocumento=\").concat(numeroDocumento));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Cria um novo cidadão\n */ const createCidadao = async (cidadao)=>{\n    try {\n        const response = await apiClient.post(\"/cidadaos\", cidadao);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza um cidadão existente\n */ const updateCidadao = async (id, cidadao)=>{\n    try {\n        const response = await apiClient.put(\"/cidadaos/\".concat(id), cidadao);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista todos os pedidos (paginado)\n */ const listPedidos = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/pedidos?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um pedido pelo ID\n */ const getPedidoById = async (id)=>{\n    try {\n        const response = await apiClient.get(\"/pedidos/\".concat(id));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um pedido pelo código de acompanhamento\n */ const getPedidoByCodigo = async (codigo)=>{\n    try {\n        const response = await apiClient.get(\"/pedidos/codigo/\".concat(codigo));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista pedidos por cidadão (paginado)\n */ const listPedidosByCidadao = async function(cidadaoId) {\n    let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, size = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    try {\n        const response = await apiClient.get(\"/pedidos/cidadao/\".concat(cidadaoId, \"?page=\").concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Cria um novo pedido\n */ const createPedido = async (pedido)=>{\n    try {\n        const response = await apiClient.post(\"/pedidos\", pedido);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza o status de um pedido\n */ const updatePedidoStatus = async (id, statusId)=>{\n    try {\n        const response = await apiClient.patch(\"/pedidos/\".concat(id, \"/status/\").concat(statusId));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os tipos de serviços disponíveis\n */ const listTiposServicos = async ()=>{\n    try {\n        const response = await apiClient.get(\"/tipos-servicos\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os tipos de serviços por categoria\n */ /**\n * Cria um novo tipo de serviço\n */ const createTipoServico = async (serviceData)=>{\n    try {\n        const response = await apiClient.post(\"/tipos-servicos\", serviceData);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os tipos de serviços por categoria\n */ const listTiposServicosByCategoria = async (categoriaId)=>{\n    try {\n        const response = await apiClient.get(\"/tipos-servicos/categoria/\".concat(categoriaId));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os serviços favoritos do usuário\n */ const listServicosFavoritos = async ()=>{\n    try {\n        const response = await apiClient.get(\"/favoritos\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Adiciona um serviço aos favoritos\n */ const addServicoFavorito = async (servicoId)=>{\n    try {\n        await apiClient.post(\"/favoritos/\".concat(servicoId));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Remove um serviço dos favoritos\n */ const removeServicoFavorito = async (servicoId)=>{\n    try {\n        await apiClient.delete(\"/favoritos/\".concat(servicoId));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Adiciona ou remove um serviço dos favoritos do usuário atual\n */ const toggleFavorito = async (tipoServicoId)=>{\n    try {\n        // O endpoint exato pode variar, ajuste conforme a API do backend\n        // Pode ser um POST para adicionar e um DELETE para remover, ou um único endpoint que faz o toggle.\n        // Aqui, vamos assumir um endpoint POST que faz o toggle.\n        // Se o backend retornar os favoritos atualizados, você pode ajustar o tipo de retorno.\n        await apiClient.post(\"/usuarios/me/favoritos/\".concat(tipoServicoId));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os itens do dashboard (paginado)\n */ const listPedidosDoUsuarioLogado = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/pedidos/meus-pedidos?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\nconst listDashboardItems = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/dashboard?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGktc2VydmljZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRUQsc0RBQXNEO0FBQzVCO0FBRWdEO0FBa0IxRSw0QkFBNEI7QUFDNUIsTUFBTUksWUFBWUosNkNBQUtBLENBQUNLLE1BQU0sQ0FBQztJQUM3QkMsU0FBU0wsaURBQVFBO0lBQ2pCTSxTQUFTSix3REFBZUE7SUFDeEJLLFNBQVNOLHdEQUFlQTtBQUMxQjtBQUVBLG1EQUFtRDtBQUNuREUsVUFBVUssWUFBWSxDQUFDQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxDQUFDQztJQUNsQyxJQUFJLElBQWtCLEVBQWE7UUFDakMsdUVBQXVFO1FBQ3ZFLElBQUlBLE9BQU9DLEdBQUcsS0FBSyxpQkFBaUJELE9BQU9DLEdBQUcsS0FBSyxrQkFBa0I7WUFDbkUsT0FBT0Q7UUFDVDtRQUVBLE1BQU1FLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxJQUFJRixPQUFPO1lBQ1QsSUFBSSxDQUFDRixPQUFPSixPQUFPLEVBQUVJLE9BQU9KLE9BQU8sR0FBRyxJQUFJUiw2Q0FBS0EsQ0FBQ2lCLFlBQVk7WUFDNURMLE9BQU9KLE9BQU8sQ0FBQ1UsYUFBYSxHQUFHLFVBQWdCLE9BQU5KO1FBQzNDO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUEsNkVBQTZFO0FBQzdFUixVQUFVSyxZQUFZLENBQUNVLFFBQVEsQ0FBQ1IsR0FBRyxDQUNqQyxDQUFDUSxXQUFhQSxVQUNkLENBQUNDO0lBQ0MsTUFBTUMsY0FBYyxLQUFrQixHQUFjQyxPQUFPQyxRQUFRLENBQUNDLFFBQVEsR0FBRztJQUMvRSw4REFBOEQ7SUFDOUQsSUFBSUosTUFBTUQsUUFBUSxJQUFLQyxDQUFBQSxNQUFNRCxRQUFRLENBQUNNLE1BQU0sS0FBSyxPQUFPTCxNQUFNRCxRQUFRLENBQUNNLE1BQU0sS0FBSyxHQUFFLEdBQUk7UUFDdEYsK0VBQStF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QU9YLE9BQU87UUFDZCxNQUFNVSxlQUFlVjtJQUN2QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS1zZXJ2aWNlcy50cz9jMDRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2VydmnDp29zIGRlIEFQSSBwYXJhIG8gc2lzdGVtYSBTaW1wbGVcbiAqIEVzdGUgYXJxdWl2byBjb250w6ltIGFzIGZ1bsOnw7VlcyBwYXJhIGludGVyYWdpciBjb20gbyBiYWNrZW5kXG4gKi9cblxuLy8gRmlyc3QgaW5zdGFsbCBheGlvczogbnBtIGluc3RhbGwgYXhpb3MgQHR5cGVzL2F4aW9zXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHR5cGUgeyBBeGlvc0Vycm9yLCBBeGlvc1JlcXVlc3RDb25maWcsIEludGVybmFsQXhpb3NSZXF1ZXN0Q29uZmlnIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgQVBJX0JBU0UsIERFRkFVTFRfSEVBREVSUywgREVGQVVMVF9USU1FT1VUIH0gZnJvbSAnLi9hcGktY29uZmlnJztcbmltcG9ydCB7XG4gIEFwaUVycm9yLFxuICBBdXRoUmVxdWVzdCxcbiAgQXV0aFJlc3BvbnNlLFxuICBDaWRhZGFvUmVxdWVzdCxcbiAgQ2lkYWRhb1Jlc3BvbnNlLFxuICBEYXNoYm9hcmRJdGVtLFxuICBQYWdpbmF0ZWRSZXNwb25zZSxcbiAgUGVkaWRvUmVxdWVzdCxcbiAgUGVkaWRvUmVzcG9uc2UsXG4gIFJlcXVlc3RTdGF0dXMsXG4gIFJlcXVlc3RUeXBlLFxuICBUaXBvU2VydmljbyxcbiAgVXN1YXJpb1JlcXVlc3QsXG4gIFVzdWFyaW9SZXNwb25zZVxufSBmcm9tICcuL3R5cGVzJztcblxuLy8gQ2xpZW50ZSBheGlvcyBjb25maWd1cmFkb1xuY29uc3QgYXBpQ2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogQVBJX0JBU0UsXG4gIHRpbWVvdXQ6IERFRkFVTFRfVElNRU9VVCxcbiAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxufSk7XG5cbi8vIEludGVyY2VwdG9yIHBhcmEgYWRpY2lvbmFyIHRva2VuIGRlIGF1dGVudGljYcOnw6NvXG5hcGlDbGllbnQuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKChjb25maWc6IEludGVybmFsQXhpb3NSZXF1ZXN0Q29uZmlnKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE7Do28gYWRpY2lvbmFyIHRva2VuIGRlIGF1dGVudGljYcOnw6NvIHBhcmEgYSByb3RhIGRlIGxvZ2luIG91IHJlZ2lzdHJvXG4gICAgaWYgKGNvbmZpZy51cmwgPT09ICcvYXV0aC9sb2dpbicgfHwgY29uZmlnLnVybCA9PT0gJy9hdXRoL3JlZ2lzdGVyJykge1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgaWYgKCFjb25maWcuaGVhZGVycykgY29uZmlnLmhlYWRlcnMgPSBuZXcgYXhpb3MuQXhpb3NIZWFkZXJzKCk7XG4gICAgICBjb25maWcuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWc7XG59KTtcblxuLy8gSW50ZXJjZXB0b3IgcGFyYSB0cmF0YXIgcmVzcG9zdGFzIGdsb2JhaXMsIGluY2x1aW5kbyBlcnJvcyBkZSBhdXRlbnRpY2HDp8Ojb1xuYXBpQ2xpZW50LmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsIC8vIFBhc3NhIGFzIHJlc3Bvc3RhcyBkZSBzdWNlc3NvIGRpcmV0YW1lbnRlXG4gIChlcnJvcjogQXhpb3NFcnJvcikgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgOiAnJztcbiAgICAvLyBWZXJpZmljYSBzZSBvIGVycm8gw6kgNDAxIChOw6NvIEF1dG9yaXphZG8pIE9VIDQwMyAoUHJvaWJpZG8pXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlICYmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQwMykpIHtcbiAgICAgIC8vIEV2aXRhIGxvb3BzIGRlIHJlZGlyZWNpb25hbWVudG8gc2UgasOhIGVzdGl2ZXIgbmEgcMOhZ2luYSBkZSBsb2dpbiBvdSByZWdpc3Ryb1xuICAgICAgaWYgKGN1cnJlbnRQYXRoICYmIGN1cnJlbnRQYXRoICE9PSAnL2xvZ2luJyAmJiBjdXJyZW50UGF0aCAhPT0gJy9yZWdpc3RlcicpIHtcbiAgICAgICAgbG9nb3V0KCk7IC8vIExpbXBhIG8gdG9rZW4gZSBjb29raWVzXG4gICAgICAgIC8vIFJlZGlyZWNpb25hIHBhcmEgYSBww6FnaW5hIGRlIGxvZ2luXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9sb2dpbic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0b3JuYSB1bWEgcHJvbWVzc2EgcXVlIG51bmNhIHJlc29sdmUgcGFyYSBldml0YXIgcXVlIG8gY2hhbWFkb3Igb3JpZ2luYWxcbiAgICAgICAgLy8gdGVudGUgYXR1YWxpemFyIG8gZXN0YWRvIGRlIHVtIGNvbXBvbmVudGUgZGVzbW9udGFkby5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUGFyYSB0b2RvcyBvcyBvdXRyb3MgZXJyb3MsIG91IHNlIGrDoSBlc3RpdmVyIGVtIC9sb2dpbiBvdSAvcmVnaXN0ZXIsIHJlamVpdGEgYSBwcm9tZXNzYVxuICAgIC8vIHBhcmEgcXVlIG8gdHJhdGFtZW50byBkZSBlcnJvIGxvY2FsIHBvc3NhIG9jb3JyZXIuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBUcmF0YSBlcnJvcyBkYSBBUEkgZGUgZm9ybWEgcGFkcm9uaXphZGFcbiAqL1xuY29uc3QgaGFuZGxlQXBpRXJyb3IgPSAoZXJyb3I6IEF4aW9zRXJyb3IpOiBBcGlFcnJvciA9PiB7XG4gIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgIC8vIE8gc2Vydmlkb3IgcmVzcG9uZGV1IGNvbSB1bSBzdGF0dXMgZGUgZXJyb1xuICAgIGNvbnN0IGRhdGEgPSBlcnJvci5yZXNwb25zZS5kYXRhIGFzIGFueTtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogZGF0YS5tZXNzYWdlIHx8IGRhdGEuZXJyb3IgfHwgJ0Vycm8gZGVzY29uaGVjaWRvJyxcbiAgICAgIHN0YXR1czogZXJyb3IucmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgdGltZXN0YW1wOiBkYXRhLnRpbWVzdGFtcCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGVycm9yLnJlcXVlc3QpIHtcbiAgICAvLyBBIHJlcXVpc2nDp8OjbyBmb2kgZmVpdGEgbWFzIG7Do28gaG91dmUgcmVzcG9zdGFcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogJ07Do28gZm9pIHBvc3PDrXZlbCBjb25lY3RhciBhbyBzZXJ2aWRvcicsXG4gICAgICBzdGF0dXM6IDAsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFcnJvIGFvIGNvbmZpZ3VyYXIgYSByZXF1aXNpw6fDo29cbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCAnRXJybyBhbyBwcm9jZXNzYXIgYSByZXF1aXNpw6fDo28nLFxuICAgICAgc3RhdHVzOiAwLFxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogUmVhbGl6YSBsb2dpbiBubyBzaXN0ZW1hXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dpbiA9IGFzeW5jIChjcmVkZW50aWFsczogQXV0aFJlcXVlc3QpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3Q8QXV0aFJlc3BvbnNlPignL2F1dGgvbG9naW4nLCBjcmVkZW50aWFscyk7XG4gICAgLy8gQXJtYXplbmEgbyB0b2tlbiBwYXJhIHVzbyBmdXR1cm9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2tlbicsIHJlc3BvbnNlLmRhdGEudG9rZW4pO1xuICAgICAgLy8gU2FsdmEgbyB0b2tlbiBjb21vIGNvb2tpZVxuICAgICAgZG9jdW1lbnQuY29va2llID0gYHRva2VuPSR7cmVzcG9uc2UuZGF0YS50b2tlbn07IHBhdGg9LzsgbWF4LWFnZT0kezYwICogNjAgKiAyNCAqIDd9OyBTYW1lU2l0ZT1MYXhgOyAvLyBFeHBpcmEgZW0gNyBkaWFzXG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlYWxpemEgbG9nb3V0IGRvIHNpc3RlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ291dCA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Rva2VuJyk7XG4gICAgLy8gUmVtb3ZlIG8gY29va2llIGRvIHRva2VuXG4gICAgZG9jdW1lbnQuY29va2llID0gJ3Rva2VuPTsgcGF0aD0vOyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UOyBTYW1lU2l0ZT1MYXgnO1xuICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdHJhIHVtIG5vdm8gdXN1w6FyaW9cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyVXNlciA9IGFzeW5jICh1c2VyOiBVc3VhcmlvUmVxdWVzdCk6IFByb21pc2U8VXN1YXJpb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdDxVc3VhcmlvUmVzcG9uc2U+KCcvYXV0aC9yZWdpc3RlcicsIHVzZXIpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIE9idMOpbSBvIHVzdcOhcmlvIGF0dWFsXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50VXNlciA9IGFzeW5jICgpOiBQcm9taXNlPFVzdWFyaW9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxVc3VhcmlvUmVzcG9uc2U+KCcvdXNlcnMvbWUnKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHVhbGl6YSBvIHBlcmZpbCBkbyB1c3XDoXJpbyBhdHVhbFxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlVXNlclByb2ZpbGUgPSBhc3luYyAodXNlckRhdGE6IFBhcnRpYWw8VXN1YXJpb1JlcXVlc3Q+KTogUHJvbWlzZTxVc3VhcmlvUmVzcG9uc2U+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQ8VXN1YXJpb1Jlc3BvbnNlPignL3VzZXJzL21lJywgdXNlckRhdGEpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIExpc3RhIHRvZG9zIG9zIGNpZGFkw6NvcyAocGFnaW5hZG8pXG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0Q2lkYWRhb3MgPSBhc3luYyAoXG4gIHBhZ2U6IG51bWJlciA9IDAsXG4gIHNpemU6IG51bWJlciA9IDEwXG4pOiBQcm9taXNlPFBhZ2luYXRlZFJlc3BvbnNlPENpZGFkYW9SZXNwb25zZT4+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQ8UGFnaW5hdGVkUmVzcG9uc2U8Q2lkYWRhb1Jlc3BvbnNlPj4oXG4gICAgICBgL2NpZGFkYW9zP3BhZ2U9JHtwYWdlfSZzaXplPSR7c2l6ZX1gXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnTDqW0gdW0gY2lkYWTDo28gcGVsbyBJRFxuICovXG5leHBvcnQgY29uc3QgZ2V0Q2lkYWRhb0J5SWQgPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8Q2lkYWRhb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PENpZGFkYW9SZXNwb25zZT4oYC9jaWRhZGFvcy8ke2lkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIE9idMOpbSB1bSBjaWRhZMOjbyBwZWxvIGRvY3VtZW50b1xuICovXG5leHBvcnQgY29uc3QgZ2V0Q2lkYWRhb0J5RG9jdW1lbnRvID0gYXN5bmMgKFxuICB0aXBvRG9jdW1lbnRvOiBzdHJpbmcsXG4gIG51bWVyb0RvY3VtZW50bzogc3RyaW5nXG4pOiBQcm9taXNlPENpZGFkYW9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxDaWRhZGFvUmVzcG9uc2U+KFxuICAgICAgYC9jaWRhZGFvcy9kb2N1bWVudG8/dGlwb0RvY3VtZW50bz0ke3RpcG9Eb2N1bWVudG99Jm51bWVyb0RvY3VtZW50bz0ke251bWVyb0RvY3VtZW50b31gXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmlhIHVtIG5vdm8gY2lkYWTDo29cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNpZGFkYW8gPSBhc3luYyAoY2lkYWRhbzogQ2lkYWRhb1JlcXVlc3QpOiBQcm9taXNlPENpZGFkYW9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3Q8Q2lkYWRhb1Jlc3BvbnNlPignL2NpZGFkYW9zJywgY2lkYWRhbyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQXR1YWxpemEgdW0gY2lkYWTDo28gZXhpc3RlbnRlXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVDaWRhZGFvID0gYXN5bmMgKFxuICBpZDogc3RyaW5nLFxuICBjaWRhZGFvOiBDaWRhZGFvUmVxdWVzdFxuKTogUHJvbWlzZTxDaWRhZGFvUmVzcG9uc2U+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQ8Q2lkYWRhb1Jlc3BvbnNlPihgL2NpZGFkYW9zLyR7aWR9YCwgY2lkYWRhbyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogTGlzdGEgdG9kb3Mgb3MgcGVkaWRvcyAocGFnaW5hZG8pXG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0UGVkaWRvcyA9IGFzeW5jIChcbiAgcGFnZTogbnVtYmVyID0gMCxcbiAgc2l6ZTogbnVtYmVyID0gMTBcbik6IFByb21pc2U8UGFnaW5hdGVkUmVzcG9uc2U8UGVkaWRvUmVzcG9uc2U+PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFBhZ2luYXRlZFJlc3BvbnNlPFBlZGlkb1Jlc3BvbnNlPj4oXG4gICAgICBgL3BlZGlkb3M/cGFnZT0ke3BhZ2V9JnNpemU9JHtzaXplfWBcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIE9idMOpbSB1bSBwZWRpZG8gcGVsbyBJRFxuICovXG5leHBvcnQgY29uc3QgZ2V0UGVkaWRvQnlJZCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxQZWRpZG9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxQZWRpZG9SZXNwb25zZT4oYC9wZWRpZG9zLyR7aWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogT2J0w6ltIHVtIHBlZGlkbyBwZWxvIGPDs2RpZ28gZGUgYWNvbXBhbmhhbWVudG9cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFBlZGlkb0J5Q29kaWdvID0gYXN5bmMgKGNvZGlnbzogc3RyaW5nKTogUHJvbWlzZTxQZWRpZG9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxQZWRpZG9SZXNwb25zZT4oYC9wZWRpZG9zL2NvZGlnby8ke2NvZGlnb31gKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMaXN0YSBwZWRpZG9zIHBvciBjaWRhZMOjbyAocGFnaW5hZG8pXG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0UGVkaWRvc0J5Q2lkYWRhbyA9IGFzeW5jIChcbiAgY2lkYWRhb0lkOiBzdHJpbmcsXG4gIHBhZ2U6IG51bWJlciA9IDAsXG4gIHNpemU6IG51bWJlciA9IDEwXG4pOiBQcm9taXNlPFBhZ2luYXRlZFJlc3BvbnNlPFBlZGlkb1Jlc3BvbnNlPj4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxQYWdpbmF0ZWRSZXNwb25zZTxQZWRpZG9SZXNwb25zZT4+KFxuICAgICAgYC9wZWRpZG9zL2NpZGFkYW8vJHtjaWRhZGFvSWR9P3BhZ2U9JHtwYWdlfSZzaXplPSR7c2l6ZX1gXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmlhIHVtIG5vdm8gcGVkaWRvXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVQZWRpZG8gPSBhc3luYyAocGVkaWRvOiBQZWRpZG9SZXF1ZXN0KTogUHJvbWlzZTxQZWRpZG9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3Q8UGVkaWRvUmVzcG9uc2U+KCcvcGVkaWRvcycsIHBlZGlkbyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQXR1YWxpemEgbyBzdGF0dXMgZGUgdW0gcGVkaWRvXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVQZWRpZG9TdGF0dXMgPSBhc3luYyAoXG4gIGlkOiBzdHJpbmcsXG4gIHN0YXR1c0lkOiBudW1iZXJcbik6IFByb21pc2U8UGVkaWRvUmVzcG9uc2U+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wYXRjaDxQZWRpZG9SZXNwb25zZT4oYC9wZWRpZG9zLyR7aWR9L3N0YXR1cy8ke3N0YXR1c0lkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIExpc3RhIG9zIHRpcG9zIGRlIHNlcnZpw6dvcyBkaXNwb27DrXZlaXNcbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RUaXBvc1NlcnZpY29zID0gYXN5bmMgKCk6IFByb21pc2U8VGlwb1NlcnZpY29bXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxUaXBvU2Vydmljb1tdPignL3RpcG9zLXNlcnZpY29zJyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogTGlzdGEgb3MgdGlwb3MgZGUgc2VydmnDp29zIHBvciBjYXRlZ29yaWFcbiAqL1xuLyoqXG4gKiBDcmlhIHVtIG5vdm8gdGlwbyBkZSBzZXJ2acOnb1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVGlwb1NlcnZpY28gPSBhc3luYyAoc2VydmljZURhdGE6IE9taXQ8VGlwb1NlcnZpY28sICdpZCc+KTogUHJvbWlzZTxUaXBvU2Vydmljbz4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3Q8VGlwb1NlcnZpY28+KCcvdGlwb3Mtc2Vydmljb3MnLCBzZXJ2aWNlRGF0YSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogTGlzdGEgb3MgdGlwb3MgZGUgc2VydmnDp29zIHBvciBjYXRlZ29yaWFcbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RUaXBvc1NlcnZpY29zQnlDYXRlZ29yaWEgPSBhc3luYyAoY2F0ZWdvcmlhSWQ6IG51bWJlcik6IFByb21pc2U8VGlwb1NlcnZpY29bXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxUaXBvU2Vydmljb1tdPihgL3RpcG9zLXNlcnZpY29zL2NhdGVnb3JpYS8ke2NhdGVnb3JpYUlkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIExpc3RhIG9zIHNlcnZpw6dvcyBmYXZvcml0b3MgZG8gdXN1w6FyaW9cbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RTZXJ2aWNvc0Zhdm9yaXRvcyA9IGFzeW5jICgpOiBQcm9taXNlPFRpcG9TZXJ2aWNvW10+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQ8VGlwb1NlcnZpY29bXT4oJy9mYXZvcml0b3MnKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGljaW9uYSB1bSBzZXJ2acOnbyBhb3MgZmF2b3JpdG9zXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRTZXJ2aWNvRmF2b3JpdG8gPSBhc3luYyAoc2Vydmljb0lkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBhcGlDbGllbnQucG9zdChgL2Zhdm9yaXRvcy8ke3NlcnZpY29JZH1gKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgdW0gc2VydmnDp28gZG9zIGZhdm9yaXRvc1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlU2Vydmljb0Zhdm9yaXRvID0gYXN5bmMgKHNlcnZpY29JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgYXBpQ2xpZW50LmRlbGV0ZShgL2Zhdm9yaXRvcy8ke3NlcnZpY29JZH1gKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGljaW9uYSBvdSByZW1vdmUgdW0gc2VydmnDp28gZG9zIGZhdm9yaXRvcyBkbyB1c3XDoXJpbyBhdHVhbFxuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlRmF2b3JpdG8gPSBhc3luYyAodGlwb1NlcnZpY29JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gTyBlbmRwb2ludCBleGF0byBwb2RlIHZhcmlhciwgYWp1c3RlIGNvbmZvcm1lIGEgQVBJIGRvIGJhY2tlbmRcbiAgICAvLyBQb2RlIHNlciB1bSBQT1NUIHBhcmEgYWRpY2lvbmFyIGUgdW0gREVMRVRFIHBhcmEgcmVtb3Zlciwgb3UgdW0gw7puaWNvIGVuZHBvaW50IHF1ZSBmYXogbyB0b2dnbGUuXG4gICAgLy8gQXF1aSwgdmFtb3MgYXNzdW1pciB1bSBlbmRwb2ludCBQT1NUIHF1ZSBmYXogbyB0b2dnbGUuXG4gICAgLy8gU2UgbyBiYWNrZW5kIHJldG9ybmFyIG9zIGZhdm9yaXRvcyBhdHVhbGl6YWRvcywgdm9jw6ogcG9kZSBhanVzdGFyIG8gdGlwbyBkZSByZXRvcm5vLlxuICAgIGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvdXN1YXJpb3MvbWUvZmF2b3JpdG9zLyR7dGlwb1NlcnZpY29JZH1gKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMaXN0YSBvcyBpdGVucyBkbyBkYXNoYm9hcmQgKHBhZ2luYWRvKVxuICovXG5leHBvcnQgY29uc3QgbGlzdFBlZGlkb3NEb1VzdWFyaW9Mb2dhZG8gPSBhc3luYyAoXG4gIHBhZ2U6IG51bWJlciA9IDAsXG4gIHNpemU6IG51bWJlciA9IDEwXG4pOiBQcm9taXNlPFBhZ2luYXRlZFJlc3BvbnNlPFBlZGlkb1Jlc3BvbnNlPj4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxQYWdpbmF0ZWRSZXNwb25zZTxQZWRpZG9SZXNwb25zZT4+KFxuICAgICAgYC9wZWRpZG9zL21ldXMtcGVkaWRvcz9wYWdlPSR7cGFnZX0mc2l6ZT0ke3NpemV9YFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBsaXN0RGFzaGJvYXJkSXRlbXMgPSBhc3luYyAoXG4gIHBhZ2U6IG51bWJlciA9IDAsXG4gIHNpemU6IG51bWJlciA9IDEwXG4pOiBQcm9taXNlPFBhZ2luYXRlZFJlc3BvbnNlPERhc2hib2FyZEl0ZW0+PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFBhZ2luYXRlZFJlc3BvbnNlPERhc2hib2FyZEl0ZW0+PihcbiAgICAgIGAvZGFzaGJvYXJkP3BhZ2U9JHtwYWdlfSZzaXplPSR7c2l6ZX1gXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLy8gUmUtZXhwb3J0YXIgb3MgdGlwb3MgcGFyYSBmYWNpbGl0YXIgbyB1c29cbmV4cG9ydCB0eXBlIHtcbiAgQXBpRXJyb3IsXG4gIEF1dGhSZXF1ZXN0LFxuICBBdXRoUmVzcG9uc2UsXG4gIENpZGFkYW9SZXF1ZXN0LFxuICBDaWRhZGFvUmVzcG9uc2UsXG4gIERhc2hib2FyZEl0ZW0sXG4gIFBhZ2luYXRlZFJlc3BvbnNlLFxuICBQZWRpZG9SZXF1ZXN0LFxuICBQZWRpZG9SZXNwb25zZSxcbiAgUmVxdWVzdFN0YXR1cyxcbiAgUmVxdWVzdFR5cGUsXG4gIFRpcG9TZXJ2aWNvLFxuICBVc3VhcmlvUmVxdWVzdCxcbiAgVXN1YXJpb1Jlc3BvbnNlXG59O1xuXG4iXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfQkFTRSIsIkRFRkFVTFRfSEVBREVSUyIsIkRFRkFVTFRfVElNRU9VVCIsImFwaUNsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJ0aW1lb3V0IiwiaGVhZGVycyIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ1cmwiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJBeGlvc0hlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwicmVzcG9uc2UiLCJlcnJvciIsImN1cnJlbnRQYXRoIiwid2luZG93IiwibG9jYXRpb24iLCJwYXRobmFtZSIsInN0YXR1cyIsImxvZ291dCIsImhyZWYiLCJQcm9taXNlIiwicmVqZWN0IiwiaGFuZGxlQXBpRXJyb3IiLCJkYXRhIiwibWVzc2FnZSIsInRpbWVzdGFtcCIsImxvZ2luIiwiY3JlZGVudGlhbHMiLCJwb3N0Iiwic2V0SXRlbSIsImRvY3VtZW50IiwiY29va2llIiwicmVtb3ZlSXRlbSIsInJlZ2lzdGVyVXNlciIsInVzZXIiLCJnZXRDdXJyZW50VXNlciIsImdldCIsInVwZGF0ZVVzZXJQcm9maWxlIiwidXNlckRhdGEiLCJwdXQiLCJsaXN0Q2lkYWRhb3MiLCJwYWdlIiwic2l6ZSIsImdldENpZGFkYW9CeUlkIiwiaWQiLCJnZXRDaWRhZGFvQnlEb2N1bWVudG8iLCJ0aXBvRG9jdW1lbnRvIiwibnVtZXJvRG9jdW1lbnRvIiwiY3JlYXRlQ2lkYWRhbyIsImNpZGFkYW8iLCJ1cGRhdGVDaWRhZGFvIiwibGlzdFBlZGlkb3MiLCJnZXRQZWRpZG9CeUlkIiwiZ2V0UGVkaWRvQnlDb2RpZ28iLCJjb2RpZ28iLCJsaXN0UGVkaWRvc0J5Q2lkYWRhbyIsImNpZGFkYW9JZCIsImNyZWF0ZVBlZGlkbyIsInBlZGlkbyIsInVwZGF0ZVBlZGlkb1N0YXR1cyIsInN0YXR1c0lkIiwicGF0Y2giLCJsaXN0VGlwb3NTZXJ2aWNvcyIsImNyZWF0ZVRpcG9TZXJ2aWNvIiwic2VydmljZURhdGEiLCJsaXN0VGlwb3NTZXJ2aWNvc0J5Q2F0ZWdvcmlhIiwiY2F0ZWdvcmlhSWQiLCJsaXN0U2Vydmljb3NGYXZvcml0b3MiLCJhZGRTZXJ2aWNvRmF2b3JpdG8iLCJzZXJ2aWNvSWQiLCJyZW1vdmVTZXJ2aWNvRmF2b3JpdG8iLCJkZWxldGUiLCJ0b2dnbGVGYXZvcml0byIsInRpcG9TZXJ2aWNvSWQiLCJsaXN0UGVkaWRvc0RvVXN1YXJpb0xvZ2FkbyIsImxpc3REYXNoYm9hcmRJdGVtcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-services.ts\n"));

/***/ })

});
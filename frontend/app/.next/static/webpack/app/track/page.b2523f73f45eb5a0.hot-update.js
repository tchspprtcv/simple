"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/track/page",{

/***/ "(app-pages-browser)/./lib/api-services.ts":
/*!*****************************!*\
  !*** ./lib/api-services.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addServicoFavorito: function() { return /* binding */ addServicoFavorito; },\n/* harmony export */   createCidadao: function() { return /* binding */ createCidadao; },\n/* harmony export */   createPedido: function() { return /* binding */ createPedido; },\n/* harmony export */   createTipoServico: function() { return /* binding */ createTipoServico; },\n/* harmony export */   getCidadaoByDocumento: function() { return /* binding */ getCidadaoByDocumento; },\n/* harmony export */   getCidadaoById: function() { return /* binding */ getCidadaoById; },\n/* harmony export */   getCurrentUser: function() { return /* binding */ getCurrentUser; },\n/* harmony export */   getPedidoByCodigo: function() { return /* binding */ getPedidoByCodigo; },\n/* harmony export */   getPedidoById: function() { return /* binding */ getPedidoById; },\n/* harmony export */   listCidadaos: function() { return /* binding */ listCidadaos; },\n/* harmony export */   listDashboardItems: function() { return /* binding */ listDashboardItems; },\n/* harmony export */   listPedidos: function() { return /* binding */ listPedidos; },\n/* harmony export */   listPedidosByCidadao: function() { return /* binding */ listPedidosByCidadao; },\n/* harmony export */   listPedidosDoUsuarioLogado: function() { return /* binding */ listPedidosDoUsuarioLogado; },\n/* harmony export */   listServicosFavoritos: function() { return /* binding */ listServicosFavoritos; },\n/* harmony export */   listTiposServicos: function() { return /* binding */ listTiposServicos; },\n/* harmony export */   listTiposServicosByCategoria: function() { return /* binding */ listTiposServicosByCategoria; },\n/* harmony export */   login: function() { return /* binding */ login; },\n/* harmony export */   logout: function() { return /* binding */ logout; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   removeServicoFavorito: function() { return /* binding */ removeServicoFavorito; },\n/* harmony export */   toggleFavorito: function() { return /* binding */ toggleFavorito; },\n/* harmony export */   updateCidadao: function() { return /* binding */ updateCidadao; },\n/* harmony export */   updatePedidoStatus: function() { return /* binding */ updatePedidoStatus; },\n/* harmony export */   updateUserProfile: function() { return /* binding */ updateUserProfile; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _api_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api-config */ \"(app-pages-browser)/./lib/api-config.ts\");\n/**\n * Serviços de API para o sistema Simple\n * Este arquivo contém as funções para interagir com o backend\n */ // First install axios: npm install axios @types/axios\n\n\n// Cliente axios configurado\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n    baseURL: _api_config__WEBPACK_IMPORTED_MODULE_0__.API_BASE,\n    timeout: _api_config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT,\n    headers: _api_config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS\n});\n// Interceptor para adicionar token de autenticação\napiClient.interceptors.request.use((config)=>{\n    if (true) {\n        // Não adicionar token de autenticação para a rota de login ou registro\n        if (config.url === \"/auth/login\" || config.url === \"/auth/register\") {\n            return config;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (token) {\n            if (!config.headers) config.headers = new axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].AxiosHeaders();\n            config.headers.Authorization = \"Bearer \".concat(token);\n        }\n    }\n    return config;\n});\n// Interceptor para tratar respostas globais, incluindo erros de autenticação\napiClient.interceptors.response.use((response)=>response, (error)=>{\n    const currentPath =  true ? window.location.pathname : 0;\n    // Verifica se o erro é 401 (Não Autorizado)\n    if (error.response && error.response.status === 401) {\n        // Evita loops de redirecionamento se já estiver na página de login ou registro\n        if (currentPath && currentPath !== \"/login\" && currentPath !== \"/register\") {\n            logout(); // Limpa o token e cookies\n            // Redireciona para a página de login\n            if (true) {\n                window.location.href = \"/login\";\n            }\n            // Retorna uma promessa que nunca resolve para evitar que o chamador original\n            // tente atualizar o estado de um componente desmontado.\n            return new Promise(()=>{});\n        }\n    }\n    // Para todos os outros erros, ou se já estiver em /login ou /register, rejeita a promessa\n    // para que o tratamento de erro local possa ocorrer.\n    return Promise.reject(error);\n});\n/**\n * Trata erros da API de forma padronizada\n */ const handleApiError = (error)=>{\n    if (error.response) {\n        // O servidor respondeu com um status de erro\n        const data = error.response.data;\n        return {\n            message: data.message || data.error || \"Erro desconhecido\",\n            status: error.response.status,\n            timestamp: data.timestamp\n        };\n    } else if (error.request) {\n        // A requisição foi feita mas não houve resposta\n        return {\n            message: \"N\\xe3o foi poss\\xedvel conectar ao servidor\",\n            status: 0\n        };\n    } else {\n        // Erro ao configurar a requisição\n        return {\n            message: error.message || \"Erro ao processar a requisi\\xe7\\xe3o\",\n            status: 0\n        };\n    }\n};\n/**\n * Realiza login no sistema\n */ const login = async (credentials)=>{\n    try {\n        const response = await apiClient.post(\"/auth/login\", credentials);\n        // Armazena o token para uso futuro\n        if (true) {\n            localStorage.setItem(\"token\", response.data.token);\n            // Salva o token como cookie\n            document.cookie = \"token=\".concat(response.data.token, \"; path=/; max-age=\").concat(60 * 60 * 24 * 7, \"; SameSite=Lax\"); // Expira em 7 dias\n        }\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Realiza logout do sistema\n */ const logout = ()=>{\n    if (true) {\n        localStorage.removeItem(\"token\");\n        // Remove o cookie do token\n        document.cookie = \"token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Lax\";\n    }\n};\n/**\n * Registra um novo usuário\n */ const registerUser = async (user)=>{\n    try {\n        const response = await apiClient.post(\"/auth/register\", user);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém o usuário atual\n */ const getCurrentUser = async ()=>{\n    try {\n        const response = await apiClient.get(\"/users/me\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza o perfil do usuário atual\n */ const updateUserProfile = async (userData)=>{\n    try {\n        const response = await apiClient.put(\"/users/me\", userData);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista todos os cidadãos (paginado)\n */ const listCidadaos = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/cidadaos?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um cidadão pelo ID\n */ const getCidadaoById = async (id)=>{\n    try {\n        const response = await apiClient.get(\"/cidadaos/\".concat(id));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um cidadão pelo documento\n */ const getCidadaoByDocumento = async (tipoDocumento, numeroDocumento)=>{\n    try {\n        const response = await apiClient.get(\"/cidadaos/documento?tipoDocumento=\".concat(tipoDocumento, \"&numeroDocumento=\").concat(numeroDocumento));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Cria um novo cidadão\n */ const createCidadao = async (cidadao)=>{\n    try {\n        const response = await apiClient.post(\"/cidadaos\", cidadao);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza um cidadão existente\n */ const updateCidadao = async (id, cidadao)=>{\n    try {\n        const response = await apiClient.put(\"/cidadaos/\".concat(id), cidadao);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista todos os pedidos (paginado)\n */ const listPedidos = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/pedidos?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um pedido pelo ID\n */ const getPedidoById = async (id)=>{\n    try {\n        const response = await apiClient.get(\"/pedidos/\".concat(id));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Obtém um pedido pelo código de acompanhamento\n */ const getPedidoByCodigo = async (codigo)=>{\n    try {\n        const response = await apiClient.get(\"/pedidos/codigo/\".concat(codigo));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista pedidos por cidadão (paginado)\n */ const listPedidosByCidadao = async function(cidadaoId) {\n    let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, size = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    try {\n        const response = await apiClient.get(\"/pedidos/cidadao/\".concat(cidadaoId, \"?page=\").concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Cria um novo pedido\n */ const createPedido = async (pedido)=>{\n    try {\n        const response = await apiClient.post(\"/pedidos\", pedido);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Atualiza o status de um pedido\n */ const updatePedidoStatus = async (id, statusId)=>{\n    try {\n        const response = await apiClient.patch(\"/pedidos/\".concat(id, \"/status/\").concat(statusId));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os tipos de serviços disponíveis\n */ const listTiposServicos = async ()=>{\n    try {\n        const response = await apiClient.get(\"/tipos-servicos\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os tipos de serviços por categoria\n */ /**\n * Cria um novo tipo de serviço\n */ const createTipoServico = async (serviceData)=>{\n    try {\n        const response = await apiClient.post(\"/tipos-servicos\", serviceData);\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os tipos de serviços por categoria\n */ const listTiposServicosByCategoria = async (categoriaId)=>{\n    try {\n        const response = await apiClient.get(\"/tipos-servicos/categoria/\".concat(categoriaId));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os serviços favoritos do usuário\n */ const listServicosFavoritos = async ()=>{\n    try {\n        const response = await apiClient.get(\"/favoritos\");\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Adiciona um serviço aos favoritos\n */ const addServicoFavorito = async (servicoId)=>{\n    try {\n        await apiClient.post(\"/favoritos/\".concat(servicoId));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Remove um serviço dos favoritos\n */ const removeServicoFavorito = async (servicoId)=>{\n    try {\n        await apiClient.delete(\"/favoritos/\".concat(servicoId));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Adiciona ou remove um serviço dos favoritos do usuário atual\n */ const toggleFavorito = async (tipoServicoId)=>{\n    try {\n        // O endpoint exato pode variar, ajuste conforme a API do backend\n        // Pode ser um POST para adicionar e um DELETE para remover, ou um único endpoint que faz o toggle.\n        // Aqui, vamos assumir um endpoint POST que faz o toggle.\n        // Se o backend retornar os favoritos atualizados, você pode ajustar o tipo de retorno.\n        await apiClient.post(\"/usuarios/me/favoritos/\".concat(tipoServicoId));\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n/**\n * Lista os itens do dashboard (paginado)\n */ const listPedidosDoUsuarioLogado = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/pedidos/meus-pedidos?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\nconst listDashboardItems = async function() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    try {\n        const response = await apiClient.get(\"/dashboard?page=\".concat(page, \"&size=\").concat(size));\n        return response.data;\n    } catch (error) {\n        throw handleApiError(error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGktc2VydmljZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRUQsc0RBQXNEO0FBQzVCO0FBRWdEO0FBa0IxRSw0QkFBNEI7QUFDNUIsTUFBTUksWUFBWUosNkNBQUtBLENBQUNLLE1BQU0sQ0FBQztJQUM3QkMsU0FBU0wsaURBQVFBO0lBQ2pCTSxTQUFTSix3REFBZUE7SUFDeEJLLFNBQVNOLHdEQUFlQTtBQUMxQjtBQUVBLG1EQUFtRDtBQUNuREUsVUFBVUssWUFBWSxDQUFDQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxDQUFDQztJQUNsQyxJQUFJLElBQWtCLEVBQWE7UUFDakMsdUVBQXVFO1FBQ3ZFLElBQUlBLE9BQU9DLEdBQUcsS0FBSyxpQkFBaUJELE9BQU9DLEdBQUcsS0FBSyxrQkFBa0I7WUFDbkUsT0FBT0Q7UUFDVDtRQUVBLE1BQU1FLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxJQUFJRixPQUFPO1lBQ1QsSUFBSSxDQUFDRixPQUFPSixPQUFPLEVBQUVJLE9BQU9KLE9BQU8sR0FBRyxJQUFJUiw2Q0FBS0EsQ0FBQ2lCLFlBQVk7WUFDNURMLE9BQU9KLE9BQU8sQ0FBQ1UsYUFBYSxHQUFHLFVBQWdCLE9BQU5KO1FBQzNDO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUEsNkVBQTZFO0FBQzdFUixVQUFVSyxZQUFZLENBQUNVLFFBQVEsQ0FBQ1IsR0FBRyxDQUNqQyxDQUFDUSxXQUFhQSxVQUNkLENBQUNDO0lBQ0MsTUFBTUMsY0FBYyxLQUFrQixHQUFjQyxPQUFPQyxRQUFRLENBQUNDLFFBQVEsR0FBRztJQUMvRSw0Q0FBNEM7SUFDNUMsSUFBSUosTUFBTUQsUUFBUSxJQUFJQyxNQUFNRCxRQUFRLENBQUNNLE1BQU0sS0FBSyxLQUFLO1FBQ25ELCtFQUErRTtRQUMvRSxJQUFJSixlQUFlQSxnQkFBZ0IsWUFBWUEsZ0JBQWdCLGFBQWE7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c291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGktc2VydmljZXMudHM/YzA0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNlcnZpw6dvcyBkZSBBUEkgcGFyYSBvIHNpc3RlbWEgU2ltcGxlXG4gKiBFc3RlIGFycXVpdm8gY29udMOpbSBhcyBmdW7Dp8O1ZXMgcGFyYSBpbnRlcmFnaXIgY29tIG8gYmFja2VuZFxuICovXG5cbi8vIEZpcnN0IGluc3RhbGwgYXhpb3M6IG5wbSBpbnN0YWxsIGF4aW9zIEB0eXBlcy9heGlvc1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB0eXBlIHsgQXhpb3NFcnJvciwgQXhpb3NSZXF1ZXN0Q29uZmlnLCBJbnRlcm5hbEF4aW9zUmVxdWVzdENvbmZpZyB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IEFQSV9CQVNFLCBERUZBVUxUX0hFQURFUlMsIERFRkFVTFRfVElNRU9VVCB9IGZyb20gJy4vYXBpLWNvbmZpZyc7XG5pbXBvcnQge1xuICBBcGlFcnJvcixcbiAgQXV0aFJlcXVlc3QsXG4gIEF1dGhSZXNwb25zZSxcbiAgQ2lkYWRhb1JlcXVlc3QsXG4gIENpZGFkYW9SZXNwb25zZSxcbiAgRGFzaGJvYXJkSXRlbSxcbiAgUGFnaW5hdGVkUmVzcG9uc2UsXG4gIFBlZGlkb1JlcXVlc3QsXG4gIFBlZGlkb1Jlc3BvbnNlLFxuICBSZXF1ZXN0U3RhdHVzLFxuICBSZXF1ZXN0VHlwZSxcbiAgVGlwb1NlcnZpY28sXG4gIFVzdWFyaW9SZXF1ZXN0LFxuICBVc3VhcmlvUmVzcG9uc2Vcbn0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIENsaWVudGUgYXhpb3MgY29uZmlndXJhZG9cbmNvbnN0IGFwaUNsaWVudCA9IGF4aW9zLmNyZWF0ZSh7XG4gIGJhc2VVUkw6IEFQSV9CQVNFLFxuICB0aW1lb3V0OiBERUZBVUxUX1RJTUVPVVQsXG4gIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbn0pO1xuXG4vLyBJbnRlcmNlcHRvciBwYXJhIGFkaWNpb25hciB0b2tlbiBkZSBhdXRlbnRpY2HDp8Ojb1xuYXBpQ2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZSgoY29uZmlnOiBJbnRlcm5hbEF4aW9zUmVxdWVzdENvbmZpZykgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOw6NvIGFkaWNpb25hciB0b2tlbiBkZSBhdXRlbnRpY2HDp8OjbyBwYXJhIGEgcm90YSBkZSBsb2dpbiBvdSByZWdpc3Ryb1xuICAgIGlmIChjb25maWcudXJsID09PSAnL2F1dGgvbG9naW4nIHx8IGNvbmZpZy51cmwgPT09ICcvYXV0aC9yZWdpc3RlcicpIHtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGlmICghY29uZmlnLmhlYWRlcnMpIGNvbmZpZy5oZWFkZXJzID0gbmV3IGF4aW9zLkF4aW9zSGVhZGVycygpO1xuICAgICAgY29uZmlnLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnO1xufSk7XG5cbi8vIEludGVyY2VwdG9yIHBhcmEgdHJhdGFyIHJlc3Bvc3RhcyBnbG9iYWlzLCBpbmNsdWluZG8gZXJyb3MgZGUgYXV0ZW50aWNhw6fDo29cbmFwaUNsaWVudC5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKFxuICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLCAvLyBQYXNzYSBhcyByZXNwb3N0YXMgZGUgc3VjZXNzbyBkaXJldGFtZW50ZVxuICAoZXJyb3I6IEF4aW9zRXJyb3IpID0+IHtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lIDogJyc7XG4gICAgLy8gVmVyaWZpY2Egc2UgbyBlcnJvIMOpIDQwMSAoTsOjbyBBdXRvcml6YWRvKVxuICAgIGlmIChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgLy8gRXZpdGEgbG9vcHMgZGUgcmVkaXJlY2lvbmFtZW50byBzZSBqw6EgZXN0aXZlciBuYSBww6FnaW5hIGRlIGxvZ2luIG91IHJlZ2lzdHJvXG4gICAgICBpZiAoY3VycmVudFBhdGggJiYgY3VycmVudFBhdGggIT09ICcvbG9naW4nICYmIGN1cnJlbnRQYXRoICE9PSAnL3JlZ2lzdGVyJykge1xuICAgICAgICBsb2dvdXQoKTsgLy8gTGltcGEgbyB0b2tlbiBlIGNvb2tpZXNcbiAgICAgICAgLy8gUmVkaXJlY2lvbmEgcGFyYSBhIHDDoWdpbmEgZGUgbG9naW5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnL2xvZ2luJztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXRvcm5hIHVtYSBwcm9tZXNzYSBxdWUgbnVuY2EgcmVzb2x2ZSBwYXJhIGV2aXRhciBxdWUgbyBjaGFtYWRvciBvcmlnaW5hbFxuICAgICAgICAvLyB0ZW50ZSBhdHVhbGl6YXIgbyBlc3RhZG8gZGUgdW0gY29tcG9uZW50ZSBkZXNtb250YWRvLlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJhIHRvZG9zIG9zIG91dHJvcyBlcnJvcywgb3Ugc2UgasOhIGVzdGl2ZXIgZW0gL2xvZ2luIG91IC9yZWdpc3RlciwgcmVqZWl0YSBhIHByb21lc3NhXG4gICAgLy8gcGFyYSBxdWUgbyB0cmF0YW1lbnRvIGRlIGVycm8gbG9jYWwgcG9zc2Egb2NvcnJlci5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG4pO1xuXG4vKipcbiAqIFRyYXRhIGVycm9zIGRhIEFQSSBkZSBmb3JtYSBwYWRyb25pemFkYVxuICovXG5jb25zdCBoYW5kbGVBcGlFcnJvciA9IChlcnJvcjogQXhpb3NFcnJvcik6IEFwaUVycm9yID0+IHtcbiAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XG4gICAgLy8gTyBzZXJ2aWRvciByZXNwb25kZXUgY29tIHVtIHN0YXR1cyBkZSBlcnJvXG4gICAgY29uc3QgZGF0YSA9IGVycm9yLnJlc3BvbnNlLmRhdGEgYXMgYW55O1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiBkYXRhLm1lc3NhZ2UgfHwgZGF0YS5lcnJvciB8fCAnRXJybyBkZXNjb25oZWNpZG8nLFxuICAgICAgc3RhdHVzOiBlcnJvci5yZXNwb25zZS5zdGF0dXMsXG4gICAgICB0aW1lc3RhbXA6IGRhdGEudGltZXN0YW1wLFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZXJyb3IucmVxdWVzdCkge1xuICAgIC8vIEEgcmVxdWlzacOnw6NvIGZvaSBmZWl0YSBtYXMgbsOjbyBob3V2ZSByZXNwb3N0YVxuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiAnTsOjbyBmb2kgcG9zc8OtdmVsIGNvbmVjdGFyIGFvIHNlcnZpZG9yJyxcbiAgICAgIHN0YXR1czogMCxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIEVycm8gYW8gY29uZmlndXJhciBhIHJlcXVpc2nDp8Ojb1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvIGFvIHByb2Nlc3NhciBhIHJlcXVpc2nDp8OjbycsXG4gICAgICBzdGF0dXM6IDAsXG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWFsaXphIGxvZ2luIG5vIHNpc3RlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ2luID0gYXN5bmMgKGNyZWRlbnRpYWxzOiBBdXRoUmVxdWVzdCk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdDxBdXRoUmVzcG9uc2U+KCcvYXV0aC9sb2dpbicsIGNyZWRlbnRpYWxzKTtcbiAgICAvLyBBcm1hemVuYSBvIHRva2VuIHBhcmEgdXNvIGZ1dHVyb1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rva2VuJywgcmVzcG9uc2UuZGF0YS50b2tlbik7XG4gICAgICAvLyBTYWx2YSBvIHRva2VuIGNvbW8gY29va2llXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBgdG9rZW49JHtyZXNwb25zZS5kYXRhLnRva2VufTsgcGF0aD0vOyBtYXgtYWdlPSR7NjAgKiA2MCAqIDI0ICogN307IFNhbWVTaXRlPUxheGA7IC8vIEV4cGlyYSBlbSA3IGRpYXNcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogUmVhbGl6YSBsb2dvdXQgZG8gc2lzdGVtYVxuICovXG5leHBvcnQgY29uc3QgbG9nb3V0ID0gKCk6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndG9rZW4nKTtcbiAgICAvLyBSZW1vdmUgbyBjb29raWUgZG8gdG9rZW5cbiAgICBkb2N1bWVudC5jb29raWUgPSAndG9rZW49OyBwYXRoPS87IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBHTVQ7IFNhbWVTaXRlPUxheCc7XG4gIH1cbn07XG5cbi8qKlxuICogUmVnaXN0cmEgdW0gbm92byB1c3XDoXJpb1xuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJVc2VyID0gYXN5bmMgKHVzZXI6IFVzdWFyaW9SZXF1ZXN0KTogUHJvbWlzZTxVc3VhcmlvUmVzcG9uc2U+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0PFVzdWFyaW9SZXNwb25zZT4oJy9hdXRoL3JlZ2lzdGVyJywgdXNlcik7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogT2J0w6ltIG8gdXN1w6FyaW8gYXR1YWxcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRVc2VyID0gYXN5bmMgKCk6IFByb21pc2U8VXN1YXJpb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFVzdWFyaW9SZXNwb25zZT4oJy91c2Vycy9tZScpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dWFsaXphIG8gcGVyZmlsIGRvIHVzdcOhcmlvIGF0dWFsXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyUHJvZmlsZSA9IGFzeW5jICh1c2VyRGF0YTogUGFydGlhbDxVc3VhcmlvUmVxdWVzdD4pOiBQcm9taXNlPFVzdWFyaW9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnB1dDxVc3VhcmlvUmVzcG9uc2U+KCcvdXNlcnMvbWUnLCB1c2VyRGF0YSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogTGlzdGEgdG9kb3Mgb3MgY2lkYWTDo29zIChwYWdpbmFkbylcbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RDaWRhZGFvcyA9IGFzeW5jIChcbiAgcGFnZTogbnVtYmVyID0gMCxcbiAgc2l6ZTogbnVtYmVyID0gMTBcbik6IFByb21pc2U8UGFnaW5hdGVkUmVzcG9uc2U8Q2lkYWRhb1Jlc3BvbnNlPj4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxQYWdpbmF0ZWRSZXNwb25zZTxDaWRhZGFvUmVzcG9uc2U+PihcbiAgICAgIGAvY2lkYWRhb3M/cGFnZT0ke3BhZ2V9JnNpemU9JHtzaXplfWBcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIE9idMOpbSB1bSBjaWRhZMOjbyBwZWxvIElEXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDaWRhZGFvQnlJZCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxDaWRhZGFvUmVzcG9uc2U+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQ8Q2lkYWRhb1Jlc3BvbnNlPihgL2NpZGFkYW9zLyR7aWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogT2J0w6ltIHVtIGNpZGFkw6NvIHBlbG8gZG9jdW1lbnRvXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDaWRhZGFvQnlEb2N1bWVudG8gPSBhc3luYyAoXG4gIHRpcG9Eb2N1bWVudG86IHN0cmluZyxcbiAgbnVtZXJvRG9jdW1lbnRvOiBzdHJpbmdcbik6IFByb21pc2U8Q2lkYWRhb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PENpZGFkYW9SZXNwb25zZT4oXG4gICAgICBgL2NpZGFkYW9zL2RvY3VtZW50bz90aXBvRG9jdW1lbnRvPSR7dGlwb0RvY3VtZW50b30mbnVtZXJvRG9jdW1lbnRvPSR7bnVtZXJvRG9jdW1lbnRvfWBcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIENyaWEgdW0gbm92byBjaWRhZMOjb1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ2lkYWRhbyA9IGFzeW5jIChjaWRhZGFvOiBDaWRhZGFvUmVxdWVzdCk6IFByb21pc2U8Q2lkYWRhb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdDxDaWRhZGFvUmVzcG9uc2U+KCcvY2lkYWRhb3MnLCBjaWRhZGFvKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHVhbGl6YSB1bSBjaWRhZMOjbyBleGlzdGVudGVcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUNpZGFkYW8gPSBhc3luYyAoXG4gIGlkOiBzdHJpbmcsXG4gIGNpZGFkYW86IENpZGFkYW9SZXF1ZXN0XG4pOiBQcm9taXNlPENpZGFkYW9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnB1dDxDaWRhZGFvUmVzcG9uc2U+KGAvY2lkYWRhb3MvJHtpZH1gLCBjaWRhZGFvKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMaXN0YSB0b2RvcyBvcyBwZWRpZG9zIChwYWdpbmFkbylcbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RQZWRpZG9zID0gYXN5bmMgKFxuICBwYWdlOiBudW1iZXIgPSAwLFxuICBzaXplOiBudW1iZXIgPSAxMFxuKTogUHJvbWlzZTxQYWdpbmF0ZWRSZXNwb25zZTxQZWRpZG9SZXNwb25zZT4+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQ8UGFnaW5hdGVkUmVzcG9uc2U8UGVkaWRvUmVzcG9uc2U+PihcbiAgICAgIGAvcGVkaWRvcz9wYWdlPSR7cGFnZX0mc2l6ZT0ke3NpemV9YFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogT2J0w6ltIHVtIHBlZGlkbyBwZWxvIElEXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQZWRpZG9CeUlkID0gYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPFBlZGlkb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFBlZGlkb1Jlc3BvbnNlPihgL3BlZGlkb3MvJHtpZH1gKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnTDqW0gdW0gcGVkaWRvIHBlbG8gY8OzZGlnbyBkZSBhY29tcGFuaGFtZW50b1xuICovXG5leHBvcnQgY29uc3QgZ2V0UGVkaWRvQnlDb2RpZ28gPSBhc3luYyAoY29kaWdvOiBzdHJpbmcpOiBQcm9taXNlPFBlZGlkb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFBlZGlkb1Jlc3BvbnNlPihgL3BlZGlkb3MvY29kaWdvLyR7Y29kaWdvfWApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIExpc3RhIHBlZGlkb3MgcG9yIGNpZGFkw6NvIChwYWdpbmFkbylcbiAqL1xuZXhwb3J0IGNvbnN0IGxpc3RQZWRpZG9zQnlDaWRhZGFvID0gYXN5bmMgKFxuICBjaWRhZGFvSWQ6IHN0cmluZyxcbiAgcGFnZTogbnVtYmVyID0gMCxcbiAgc2l6ZTogbnVtYmVyID0gMTBcbik6IFByb21pc2U8UGFnaW5hdGVkUmVzcG9uc2U8UGVkaWRvUmVzcG9uc2U+PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFBhZ2luYXRlZFJlc3BvbnNlPFBlZGlkb1Jlc3BvbnNlPj4oXG4gICAgICBgL3BlZGlkb3MvY2lkYWRhby8ke2NpZGFkYW9JZH0/cGFnZT0ke3BhZ2V9JnNpemU9JHtzaXplfWBcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIENyaWEgdW0gbm92byBwZWRpZG9cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVBlZGlkbyA9IGFzeW5jIChwZWRpZG86IFBlZGlkb1JlcXVlc3QpOiBQcm9taXNlPFBlZGlkb1Jlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdDxQZWRpZG9SZXNwb25zZT4oJy9wZWRpZG9zJywgcGVkaWRvKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHVhbGl6YSBvIHN0YXR1cyBkZSB1bSBwZWRpZG9cbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVBlZGlkb1N0YXR1cyA9IGFzeW5jIChcbiAgaWQ6IHN0cmluZyxcbiAgc3RhdHVzSWQ6IG51bWJlclxuKTogUHJvbWlzZTxQZWRpZG9SZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBhdGNoPFBlZGlkb1Jlc3BvbnNlPihgL3BlZGlkb3MvJHtpZH0vc3RhdHVzLyR7c3RhdHVzSWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogTGlzdGEgb3MgdGlwb3MgZGUgc2VydmnDp29zIGRpc3BvbsOtdmVpc1xuICovXG5leHBvcnQgY29uc3QgbGlzdFRpcG9zU2Vydmljb3MgPSBhc3luYyAoKTogUHJvbWlzZTxUaXBvU2Vydmljb1tdPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFRpcG9TZXJ2aWNvW10+KCcvdGlwb3Mtc2Vydmljb3MnKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMaXN0YSBvcyB0aXBvcyBkZSBzZXJ2acOnb3MgcG9yIGNhdGVnb3JpYVxuICovXG4vKipcbiAqIENyaWEgdW0gbm92byB0aXBvIGRlIHNlcnZpw6dvXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVUaXBvU2VydmljbyA9IGFzeW5jIChzZXJ2aWNlRGF0YTogT21pdDxUaXBvU2VydmljbywgJ2lkJz4pOiBQcm9taXNlPFRpcG9TZXJ2aWNvPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdDxUaXBvU2Vydmljbz4oJy90aXBvcy1zZXJ2aWNvcycsIHNlcnZpY2VEYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMaXN0YSBvcyB0aXBvcyBkZSBzZXJ2acOnb3MgcG9yIGNhdGVnb3JpYVxuICovXG5leHBvcnQgY29uc3QgbGlzdFRpcG9zU2Vydmljb3NCeUNhdGVnb3JpYSA9IGFzeW5jIChjYXRlZ29yaWFJZDogbnVtYmVyKTogUHJvbWlzZTxUaXBvU2Vydmljb1tdPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFRpcG9TZXJ2aWNvW10+KGAvdGlwb3Mtc2Vydmljb3MvY2F0ZWdvcmlhLyR7Y2F0ZWdvcmlhSWR9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IgYXMgQXhpb3NFcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogTGlzdGEgb3Mgc2VydmnDp29zIGZhdm9yaXRvcyBkbyB1c3XDoXJpb1xuICovXG5leHBvcnQgY29uc3QgbGlzdFNlcnZpY29zRmF2b3JpdG9zID0gYXN5bmMgKCk6IFByb21pc2U8VGlwb1NlcnZpY29bXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldDxUaXBvU2Vydmljb1tdPignL2Zhdm9yaXRvcycpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkaWNpb25hIHVtIHNlcnZpw6dvIGFvcyBmYXZvcml0b3NcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZFNlcnZpY29GYXZvcml0byA9IGFzeW5jIChzZXJ2aWNvSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvZmF2b3JpdG9zLyR7c2Vydmljb0lkfWApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB1bSBzZXJ2acOnbyBkb3MgZmF2b3JpdG9zXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVTZXJ2aWNvRmF2b3JpdG8gPSBhc3luYyAoc2Vydmljb0lkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBhcGlDbGllbnQuZGVsZXRlKGAvZmF2b3JpdG9zLyR7c2Vydmljb0lkfWApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkaWNpb25hIG91IHJlbW92ZSB1bSBzZXJ2acOnbyBkb3MgZmF2b3JpdG9zIGRvIHVzdcOhcmlvIGF0dWFsXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVGYXZvcml0byA9IGFzeW5jICh0aXBvU2Vydmljb0lkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBPIGVuZHBvaW50IGV4YXRvIHBvZGUgdmFyaWFyLCBhanVzdGUgY29uZm9ybWUgYSBBUEkgZG8gYmFja2VuZFxuICAgIC8vIFBvZGUgc2VyIHVtIFBPU1QgcGFyYSBhZGljaW9uYXIgZSB1bSBERUxFVEUgcGFyYSByZW1vdmVyLCBvdSB1bSDDum5pY28gZW5kcG9pbnQgcXVlIGZheiBvIHRvZ2dsZS5cbiAgICAvLyBBcXVpLCB2YW1vcyBhc3N1bWlyIHVtIGVuZHBvaW50IFBPU1QgcXVlIGZheiBvIHRvZ2dsZS5cbiAgICAvLyBTZSBvIGJhY2tlbmQgcmV0b3JuYXIgb3MgZmF2b3JpdG9zIGF0dWFsaXphZG9zLCB2b2PDqiBwb2RlIGFqdXN0YXIgbyB0aXBvIGRlIHJldG9ybm8uXG4gICAgYXdhaXQgYXBpQ2xpZW50LnBvc3QoYC91c3Vhcmlvcy9tZS9mYXZvcml0b3MvJHt0aXBvU2Vydmljb0lkfWApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vKipcbiAqIExpc3RhIG9zIGl0ZW5zIGRvIGRhc2hib2FyZCAocGFnaW5hZG8pXG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0UGVkaWRvc0RvVXN1YXJpb0xvZ2FkbyA9IGFzeW5jIChcbiAgcGFnZTogbnVtYmVyID0gMCxcbiAgc2l6ZTogbnVtYmVyID0gMTBcbik6IFByb21pc2U8UGFnaW5hdGVkUmVzcG9uc2U8UGVkaWRvUmVzcG9uc2U+PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0PFBhZ2luYXRlZFJlc3BvbnNlPFBlZGlkb1Jlc3BvbnNlPj4oXG4gICAgICBgL3BlZGlkb3MvbWV1cy1wZWRpZG9zP3BhZ2U9JHtwYWdlfSZzaXplPSR7c2l6ZX1gXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvciBhcyBBeGlvc0Vycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGxpc3REYXNoYm9hcmRJdGVtcyA9IGFzeW5jIChcbiAgcGFnZTogbnVtYmVyID0gMCxcbiAgc2l6ZTogbnVtYmVyID0gMTBcbik6IFByb21pc2U8UGFnaW5hdGVkUmVzcG9uc2U8RGFzaGJvYXJkSXRlbT4+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQ8UGFnaW5hdGVkUmVzcG9uc2U8RGFzaGJvYXJkSXRlbT4+KFxuICAgICAgYC9kYXNoYm9hcmQ/cGFnZT0ke3BhZ2V9JnNpemU9JHtzaXplfWBcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yIGFzIEF4aW9zRXJyb3IpO1xuICB9XG59O1xuXG4vLyBSZS1leHBvcnRhciBvcyB0aXBvcyBwYXJhIGZhY2lsaXRhciBvIHVzb1xuZXhwb3J0IHR5cGUge1xuICBBcGlFcnJvcixcbiAgQXV0aFJlcXVlc3QsXG4gIEF1dGhSZXNwb25zZSxcbiAgQ2lkYWRhb1JlcXVlc3QsXG4gIENpZGFkYW9SZXNwb25zZSxcbiAgRGFzaGJvYXJkSXRlbSxcbiAgUGFnaW5hdGVkUmVzcG9uc2UsXG4gIFBlZGlkb1JlcXVlc3QsXG4gIFBlZGlkb1Jlc3BvbnNlLFxuICBSZXF1ZXN0U3RhdHVzLFxuICBSZXF1ZXN0VHlwZSxcbiAgVGlwb1NlcnZpY28sXG4gIFVzdWFyaW9SZXF1ZXN0LFxuICBVc3VhcmlvUmVzcG9uc2Vcbn07XG5cbiJdLCJuYW1lcyI6WyJheGlvcyIsIkFQSV9CQVNFIiwiREVGQVVMVF9IRUFERVJTIiwiREVGQVVMVF9USU1FT1VUIiwiYXBpQ2xpZW50IiwiY3JlYXRlIiwiYmFzZVVSTCIsInRpbWVvdXQiLCJoZWFkZXJzIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImNvbmZpZyIsInVybCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkF4aW9zSGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJyZXNwb25zZSIsImVycm9yIiwiY3VycmVudFBhdGgiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwic3RhdHVzIiwibG9nb3V0IiwiaHJlZiIsIlByb21pc2UiLCJyZWplY3QiLCJoYW5kbGVBcGlFcnJvciIsImRhdGEiLCJtZXNzYWdlIiwidGltZXN0YW1wIiwibG9naW4iLCJjcmVkZW50aWFscyIsInBvc3QiLCJzZXRJdGVtIiwiZG9jdW1lbnQiLCJjb29raWUiLCJyZW1vdmVJdGVtIiwicmVnaXN0ZXJVc2VyIiwidXNlciIsImdldEN1cnJlbnRVc2VyIiwiZ2V0IiwidXBkYXRlVXNlclByb2ZpbGUiLCJ1c2VyRGF0YSIsInB1dCIsImxpc3RDaWRhZGFvcyIsInBhZ2UiLCJzaXplIiwiZ2V0Q2lkYWRhb0J5SWQiLCJpZCIsImdldENpZGFkYW9CeURvY3VtZW50byIsInRpcG9Eb2N1bWVudG8iLCJudW1lcm9Eb2N1bWVudG8iLCJjcmVhdGVDaWRhZGFvIiwiY2lkYWRhbyIsInVwZGF0ZUNpZGFkYW8iLCJsaXN0UGVkaWRvcyIsImdldFBlZGlkb0J5SWQiLCJnZXRQZWRpZG9CeUNvZGlnbyIsImNvZGlnbyIsImxpc3RQZWRpZG9zQnlDaWRhZGFvIiwiY2lkYWRhb0lkIiwiY3JlYXRlUGVkaWRvIiwicGVkaWRvIiwidXBkYXRlUGVkaWRvU3RhdHVzIiwic3RhdHVzSWQiLCJwYXRjaCIsImxpc3RUaXBvc1NlcnZpY29zIiwiY3JlYXRlVGlwb1NlcnZpY28iLCJzZXJ2aWNlRGF0YSIsImxpc3RUaXBvc1NlcnZpY29zQnlDYXRlZ29yaWEiLCJjYXRlZ29yaWFJZCIsImxpc3RTZXJ2aWNvc0Zhdm9yaXRvcyIsImFkZFNlcnZpY29GYXZvcml0byIsInNlcnZpY29JZCIsInJlbW92ZVNlcnZpY29GYXZvcml0byIsImRlbGV0ZSIsInRvZ2dsZUZhdm9yaXRvIiwidGlwb1NlcnZpY29JZCIsImxpc3RQZWRpZG9zRG9Vc3VhcmlvTG9nYWRvIiwibGlzdERhc2hib2FyZEl0ZW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-services.ts\n"));

/***/ })

});